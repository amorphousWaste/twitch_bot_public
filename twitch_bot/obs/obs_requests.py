# Auto-generated by the generate_classes.py file on: 2022/04/17. #

from typing import Optional

from obs.obs_base_classes import BaseRequests


class AddFilterToSource(BaseRequests):
    """Add a new filter to a source. Available source types along with their settings properties are available from `GetSourceTypesList`.

    Args:
        filterName (str): Name of the new filter
        filterSettings (object): Filter settings
        filterType (str): Filter type
        sourceName (str): Name of the source on which the filter is added
    """

    def __init__(self):
        """Init."""

        super(AddFilterToSource, self).__init__()

    async def init(
        self,
        filterName: str,
        filterSettings: object,
        filterType: str,
        sourceName: str,
    ):
        """Async init."""

        self.name = 'AddFilterToSource'
        self.data_out['filterName'] = filterName
        self.data_out['filterSettings'] = filterSettings
        self.data_out['filterType'] = filterType
        self.data_out['sourceName'] = sourceName
        return self


class AddSceneItem(BaseRequests):
    """Creates a scene item in a scene. In other words, this is how you add a source into a scene.

    Args:
        sceneName (str): Name of the scene to create the scene item in
        sourceName (str): Name of the source to be added
        setVisible (bool) optional: Whether to make the sceneitem visible on creation or not. Default `true`

    Returns:
        itemId (int): Numerical ID of the created scene item
    """

    def __init__(self):
        """Init."""

        super(AddSceneItem, self).__init__()

    async def init(
        self,
        sceneName: str,
        sourceName: str,
        setVisible: Optional[bool] = None,
    ):
        """Async init."""

        self.name = 'AddSceneItem'
        self.data_in['itemId'] = None
        self.data_out['sceneName'] = sceneName
        self.data_out['sourceName'] = sourceName
        self.data_out['setVisible'] = setVisible
        return self

    async def get_itemId(self):
        return self.data_in['itemId']


class Authenticate(BaseRequests):
    """Attempt to authenticate the client to the server.

    Args:
        auth (str): Response to the auth challenge (see "Authentication" for more information).
    """

    def __init__(self):
        """Init."""

        super(Authenticate, self).__init__()

    async def init(self, auth: str):
        """Async init."""

        self.name = 'Authenticate'
        self.data_out['auth'] = auth
        return self


class BroadcastCustomMessage(BaseRequests):
    """Broadcast custom message to all connected WebSocket clients

    Args:
        data (object): User-defined data
        realm (str): Identifier to be choosen by the client
    """

    def __init__(self):
        """Init."""

        super(BroadcastCustomMessage, self).__init__()

    async def init(self, data: object, realm: str):
        """Async init."""

        self.name = 'BroadcastCustomMessage'
        self.data_out['data'] = data
        self.data_out['realm'] = realm
        return self


class CreateScene(BaseRequests):
    """Create a new scene scene.

    Args:
        sceneName (str): Name of the scene to create.
    """

    def __init__(self):
        """Init."""

        super(CreateScene, self).__init__()

    async def init(self, sceneName: str):
        """Async init."""

        self.name = 'CreateScene'
        self.data_out['sceneName'] = sceneName
        return self


class CreateSource(BaseRequests):
    """Create a source and add it as a sceneitem to a scene.

    Args:
        sceneName (str): Scene to add the new source to.
        sourceKind (str): Source kind, Eg. `vlc_source`.
        sourceName (str): Source name.
        setVisible (bool) optional: Set the created SceneItem as visible or not. Defaults to true
        sourceSettings (object) optional: Source settings data.

    Returns:
        itemId (int): ID of the SceneItem in the scene.
    """

    def __init__(self):
        """Init."""

        super(CreateSource, self).__init__()

    async def init(
        self,
        sceneName: str,
        sourceKind: str,
        sourceName: str,
        setVisible: Optional[bool] = None,
        sourceSettings: Optional[object] = None,
    ):
        """Async init."""

        self.name = 'CreateSource'
        self.data_in['itemId'] = None
        self.data_out['sceneName'] = sceneName
        self.data_out['sourceKind'] = sourceKind
        self.data_out['sourceName'] = sourceName
        self.data_out['setVisible'] = setVisible
        self.data_out['sourceSettings'] = sourceSettings
        return self

    async def get_itemId(self):
        return self.data_in['itemId']


class DeleteSceneItem(BaseRequests):
    """Deletes a scene item.

    Args:
        item (object): Scene item to delete (required)
        item.id (int): Scene Item ID.
        item.name (str): Scene Item name (prefer `id`, including both is acceptable).
        scene (str) optional: Name of the scene the scene item belongs to. Defaults to the current scene.
    """

    def __init__(self):
        """Init."""

        super(DeleteSceneItem, self).__init__()

    async def init(
        self,
        item: object,
        item_id: int,
        item_name: str,
        scene: Optional[str] = None,
    ):
        """Async init."""

        self.name = 'DeleteSceneItem'
        self.data_out['item'] = item
        self.data_out['item.id'] = item_id
        self.data_out['item.name'] = item_name
        self.data_out['scene'] = scene
        return self


class DisableStudioMode(BaseRequests):
    """Disables Studio Mode."""

    def __init__(self):
        """Init."""

        super(DisableStudioMode, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'DisableStudioMode'
        return self


class DuplicateSceneItem(BaseRequests):
    """Duplicates a scene item.

    Args:
        item (object): Scene Item to duplicate from the source scene (required)
        item.id (int): Scene Item ID.
        item.name (str): Scene Item name (prefer `id`, including both is acceptable).
        fromScene (str) optional: Name of the scene to copy the item from. Defaults to the current scene.
        toScene (str) optional: Name of the scene to create the item in. Defaults to the current scene.

    Returns:
        item (object): New item info
        item.id (int): New item ID
        item.name (str): New item name
        scene (str): Name of the scene where the new item was created
    """

    def __init__(self):
        """Init."""

        super(DuplicateSceneItem, self).__init__()

    async def init(
        self,
        item: object,
        item_id: int,
        item_name: str,
        fromScene: Optional[str] = None,
        toScene: Optional[str] = None,
    ):
        """Async init."""

        self.name = 'DuplicateSceneItem'
        self.data_in['item'] = None
        self.data_in['item.id'] = None
        self.data_in['item.name'] = None
        self.data_in['scene'] = None
        self.data_out['item'] = item
        self.data_out['item.id'] = item_id
        self.data_out['item.name'] = item_name
        self.data_out['fromScene'] = fromScene
        self.data_out['toScene'] = toScene
        return self

    async def get_item(self):
        return self.data_in['item']

    async def get_item_id(self):
        return self.data_in['item.id']

    async def get_item_name(self):
        return self.data_in['item.name']

    async def get_scene(self):
        return self.data_in['scene']


class EnableStudioMode(BaseRequests):
    """Enables Studio Mode."""

    def __init__(self):
        """Init."""

        super(EnableStudioMode, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'EnableStudioMode'
        return self


class ExecuteBatch(BaseRequests):
    """Executes a list of requests sequentially (one-by-one on the same thread).

    Args:
        abortOnFail (bool): Stop processing batch requests if one returns a failure.
        requests (list): Array of requests to perform. Executed in order.
        requests.*.message-id (str): ID of the individual request. Can be any string and not required to be unique. Defaults to empty string if not specified.
        requests.*.request-type (str): Request type. Eg. `GetVersion`.

    Returns:
        results (list): Batch requests results, ordered sequentially.
        results.*.error (str): Error message accompanying an `error` status.
        results.*.message-id (str): ID of the individual request which was originally provided by the client.
        results.*.status (str): Status response as string. Either `ok` or `error`.
    """

    def __init__(self):
        """Init."""

        super(ExecuteBatch, self).__init__()

    async def init(
        self,
        abortOnFail: bool,
        requests: list,
        requests___message_id: str,
        requests___request_type: str,
    ):
        """Async init."""

        self.name = 'ExecuteBatch'
        self.data_in['results'] = None
        self.data_in['results.*.error'] = None
        self.data_in['results.*.message-id'] = None
        self.data_in['results.*.status'] = None
        self.data_out['abortOnFail'] = abortOnFail
        self.data_out['requests'] = requests
        self.data_out['requests.*.message-id'] = requests___message_id
        self.data_out['requests.*.request-type'] = requests___request_type
        return self

    async def get_results(self):
        return self.data_in['results']

    async def get_results___error(self):
        return self.data_in['results.*.error']

    async def get_results___message_id(self):
        return self.data_in['results.*.message-id']

    async def get_results___status(self):
        return self.data_in['results.*.status']


class GetAudioActive(BaseRequests):
    """Get the audio's active status of a specified source.

    Args:
        sourceName (str): Source name.

    Returns:
        audioActive (bool): Audio active status of the source.
    """

    def __init__(self):
        """Init."""

        super(GetAudioActive, self).__init__()

    async def init(self, sourceName: str):
        """Async init."""

        self.name = 'GetAudioActive'
        self.data_in['audioActive'] = None
        self.data_out['sourceName'] = sourceName
        return self

    async def get_audioActive(self):
        return self.data_in['audioActive']


class GetAudioMonitorType(BaseRequests):
    """Get the audio monitoring type of the specified source.

    Args:
        sourceName (str): Source name.

    Returns:
        monitorType (str): The monitor type in use. Options: `none`, `monitorOnly`, `monitorAndOutput`.
    """

    def __init__(self):
        """Init."""

        super(GetAudioMonitorType, self).__init__()

    async def init(self, sourceName: str):
        """Async init."""

        self.name = 'GetAudioMonitorType'
        self.data_in['monitorType'] = None
        self.data_out['sourceName'] = sourceName
        return self

    async def get_monitorType(self):
        return self.data_in['monitorType']


class GetAudioTracks(BaseRequests):
    """Gets whether an audio track is active for a source.

    Args:
        sourceName (str): Source name.

    Returns:
        track1 (bool):
        track2 (bool):
        track3 (bool):
        track4 (bool):
        track5 (bool):
        track6 (bool):
    """

    def __init__(self):
        """Init."""

        super(GetAudioTracks, self).__init__()

    async def init(self, sourceName: str):
        """Async init."""

        self.name = 'GetAudioTracks'
        self.data_in['track1'] = None
        self.data_in['track2'] = None
        self.data_in['track3'] = None
        self.data_in['track4'] = None
        self.data_in['track5'] = None
        self.data_in['track6'] = None
        self.data_out['sourceName'] = sourceName
        return self

    async def get_track1(self):
        return self.data_in['track1']

    async def get_track2(self):
        return self.data_in['track2']

    async def get_track3(self):
        return self.data_in['track3']

    async def get_track4(self):
        return self.data_in['track4']

    async def get_track5(self):
        return self.data_in['track5']

    async def get_track6(self):
        return self.data_in['track6']


class GetAuthRequired(BaseRequests):
    """Tells the client if authentication is required. If so, returns authentication parameters `challenge`
    and `salt` (see "Authentication" for more information).

        Returns:
            authRequired (bool): Indicates whether authentication is required.
            challenge (str):
            salt (str):
    """

    def __init__(self):
        """Init."""

        super(GetAuthRequired, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetAuthRequired'
        self.data_in['authRequired'] = None
        self.data_in['challenge'] = None
        self.data_in['salt'] = None
        return self

    async def get_authRequired(self):
        return self.data_in['authRequired']

    async def get_challenge(self):
        return self.data_in['challenge']

    async def get_salt(self):
        return self.data_in['salt']


class GetBrowserSourceProperties(BaseRequests):
    """Get current properties for a Browser Source.

    Args:
        source (str): Source name.

    Returns:
        css (str): CSS to inject.
        fps (int): Framerate.
        height (int): Height.
        is_local_file (bool): Indicates that a local file is in use.
        local_file (str): file path.
        shutdown (bool): Indicates whether the source should be shutdown when not visible.
        source (str): Source name.
        url (str): Url.
        width (int): Width.
    """

    def __init__(self):
        """Init."""

        super(GetBrowserSourceProperties, self).__init__()

    async def init(self, source: str):
        """Async init."""

        self.name = 'GetBrowserSourceProperties'
        self.data_in['css'] = None
        self.data_in['fps'] = None
        self.data_in['height'] = None
        self.data_in['is_local_file'] = None
        self.data_in['local_file'] = None
        self.data_in['shutdown'] = None
        self.data_in['source'] = None
        self.data_in['url'] = None
        self.data_in['width'] = None
        self.data_out['source'] = source
        return self

    async def get_css(self):
        return self.data_in['css']

    async def get_fps(self):
        return self.data_in['fps']

    async def get_height(self):
        return self.data_in['height']

    async def get_is_local_file(self):
        return self.data_in['is_local_file']

    async def get_local_file(self):
        return self.data_in['local_file']

    async def get_shutdown(self):
        return self.data_in['shutdown']

    async def get_source(self):
        return self.data_in['source']

    async def get_url(self):
        return self.data_in['url']

    async def get_width(self):
        return self.data_in['width']


class GetCurrentProfile(BaseRequests):
    """Get the name of the current profile.

    Returns:
        profile-name (str): Name of the currently active profile.
    """

    def __init__(self):
        """Init."""

        super(GetCurrentProfile, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetCurrentProfile'
        self.data_in['profile-name'] = None
        return self

    async def get_profile_name(self):
        return self.data_in['profile-name']


class GetCurrentScene(BaseRequests):
    """Get the current scene's name and source items.

    Returns:
        name (str): Name of the currently active scene.
        sources (list): Ordered list of the current scene's source items.
    """

    def __init__(self):
        """Init."""

        super(GetCurrentScene, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetCurrentScene'
        self.data_in['name'] = None
        self.data_in['sources'] = None
        return self

    async def get_name(self):
        return self.data_in['name']

    async def get_sources(self):
        return self.data_in['sources']


class GetCurrentSceneCollection(BaseRequests):
    """Get the name of the current scene collection.

    Returns:
        sc-name (str): Name of the currently active scene collection.
    """

    def __init__(self):
        """Init."""

        super(GetCurrentSceneCollection, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetCurrentSceneCollection'
        self.data_in['sc-name'] = None
        return self

    async def get_sc_name(self):
        return self.data_in['sc-name']


class GetCurrentTransition(BaseRequests):
    """Get the name of the currently selected transition in the frontend's dropdown menu.

    Returns:
        duration (int): Transition duration (in milliseconds) if supported by the transition.
        name (str): Name of the selected transition.
    """

    def __init__(self):
        """Init."""

        super(GetCurrentTransition, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetCurrentTransition'
        self.data_in['duration'] = None
        self.data_in['name'] = None
        return self

    async def get_duration(self):
        return self.data_in['duration']

    async def get_name(self):
        return self.data_in['name']


class GetFilenameFormatting(BaseRequests):
    """Get the filename formatting string

    Returns:
        filename-formatting (str): Current filename formatting string.
    """

    def __init__(self):
        """Init."""

        super(GetFilenameFormatting, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetFilenameFormatting'
        self.data_in['filename-formatting'] = None
        return self

    async def get_filename_formatting(self):
        return self.data_in['filename-formatting']


class GetMediaDuration(BaseRequests):
    """Get the length of media in milliseconds. Supports ffmpeg and vlc media sources (as of OBS v25.0.8)
    Note: For some reason, for the first 5 or so seconds that the media is playing, the total duration can be off by upwards of 50ms.

        Args:
            sourceName (str): Source name.

        Returns:
            mediaDuration (int): The total length of media in milliseconds..
    """

    def __init__(self):
        """Init."""

        super(GetMediaDuration, self).__init__()

    async def init(self, sourceName: str):
        """Async init."""

        self.name = 'GetMediaDuration'
        self.data_in['mediaDuration'] = None
        self.data_out['sourceName'] = sourceName
        return self

    async def get_mediaDuration(self):
        return self.data_in['mediaDuration']


class GetMediaSourcesList(BaseRequests):
    """List the media state of all media sources (vlc and media source)

    Returns:
        mediaSources (list): Array of sources
        mediaSources.*.mediaState (str): The current state of media for that source. States: `none`, `playing`, `opening`, `buffering`, `paused`, `stopped`, `ended`, `error`, `unknown`
        mediaSources.*.sourceKind (str): Unique source internal type (a.k.a `ffmpeg_source` or `vlc_source`)
        mediaSources.*.sourceName (str): Unique source name
    """

    def __init__(self):
        """Init."""

        super(GetMediaSourcesList, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetMediaSourcesList'
        self.data_in['mediaSources'] = None
        self.data_in['mediaSources.*.mediaState'] = None
        self.data_in['mediaSources.*.sourceKind'] = None
        self.data_in['mediaSources.*.sourceName'] = None
        return self

    async def get_mediaSources(self):
        return self.data_in['mediaSources']

    async def get_mediaSources___mediaState(self):
        return self.data_in['mediaSources.*.mediaState']

    async def get_mediaSources___sourceKind(self):
        return self.data_in['mediaSources.*.sourceKind']

    async def get_mediaSources___sourceName(self):
        return self.data_in['mediaSources.*.sourceName']


class GetMediaState(BaseRequests):
    """Get the current playing state of a media source. Supports ffmpeg and vlc media sources (as of OBS v25.0.8)

    Args:
        sourceName (str): Source name.

    Returns:
        mediaState (str): The media state of the provided source. States: `none`, `playing`, `opening`, `buffering`, `paused`, `stopped`, `ended`, `error`, `unknown`
    """

    def __init__(self):
        """Init."""

        super(GetMediaState, self).__init__()

    async def init(self, sourceName: str):
        """Async init."""

        self.name = 'GetMediaState'
        self.data_in['mediaState'] = None
        self.data_out['sourceName'] = sourceName
        return self

    async def get_mediaState(self):
        return self.data_in['mediaState']


class GetMediaTime(BaseRequests):
    """Get the current timestamp of media in milliseconds. Supports ffmpeg and vlc media sources (as of OBS v25.0.8)

    Args:
        sourceName (str): Source name.

    Returns:
        timestamp (int): The time in milliseconds since the start of the media.
    """

    def __init__(self):
        """Init."""

        super(GetMediaTime, self).__init__()

    async def init(self, sourceName: str):
        """Async init."""

        self.name = 'GetMediaTime'
        self.data_in['timestamp'] = None
        self.data_out['sourceName'] = sourceName
        return self

    async def get_timestamp(self):
        return self.data_in['timestamp']


class GetMute(BaseRequests):
    """Get the mute status of a specified source.

    Args:
        source (str): Source name.

    Returns:
        muted (bool): Mute status of the source.
        name (str): Source name.
    """

    def __init__(self):
        """Init."""

        super(GetMute, self).__init__()

    async def init(self, source: str):
        """Async init."""

        self.name = 'GetMute'
        self.data_in['muted'] = None
        self.data_in['name'] = None
        self.data_out['source'] = source
        return self

    async def get_muted(self):
        return self.data_in['muted']

    async def get_name(self):
        return self.data_in['name']


class GetOutputInfo(BaseRequests):
    """Get information about a single output

    Args:
        outputName (str): Output name

    Returns:
        outputInfo (Output): Output info
    """

    def __init__(self):
        """Init."""

        super(GetOutputInfo, self).__init__()

    async def init(self, outputName: str):
        """Async init."""

        self.name = 'GetOutputInfo'
        self.data_in['outputInfo'] = None
        self.data_out['outputName'] = outputName
        return self

    async def get_outputInfo(self):
        return self.data_in['outputInfo']


class GetPreviewScene(BaseRequests):
    """Get the name of the currently previewed scene and its list of sources.
    Will return an `error` if Studio Mode is not enabled.

        Returns:
            name (str): The name of the active preview scene.
            sources (list):
    """

    def __init__(self):
        """Init."""

        super(GetPreviewScene, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetPreviewScene'
        self.data_in['name'] = None
        self.data_in['sources'] = None
        return self

    async def get_name(self):
        return self.data_in['name']

    async def get_sources(self):
        return self.data_in['sources']


class GetRecordingFolder(BaseRequests):
    """Get the path of  the current recording folder.

    Returns:
        rec-folder (str): Path of the recording folder.
    """

    def __init__(self):
        """Init."""

        super(GetRecordingFolder, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetRecordingFolder'
        self.data_in['rec-folder'] = None
        return self

    async def get_rec_folder(self):
        return self.data_in['rec-folder']


class GetRecordingStatus(BaseRequests):
    """Get current recording status.

    Returns:
        isRecording (bool): Current recording status.
        isRecordingPaused (bool): Whether the recording is paused or not.
        recordTimecode (str): Time elapsed since recording started (only present if currently recording).
        recordingFilename (str): Absolute path to the recording file (only present if currently recording).
    """

    def __init__(self):
        """Init."""

        super(GetRecordingStatus, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetRecordingStatus'
        self.data_in['isRecording'] = None
        self.data_in['isRecordingPaused'] = None
        self.data_in['recordTimecode'] = None
        self.data_in['recordingFilename'] = None
        return self

    async def get_isRecording(self):
        return self.data_in['isRecording']

    async def get_isRecordingPaused(self):
        return self.data_in['isRecordingPaused']

    async def get_recordTimecode(self):
        return self.data_in['recordTimecode']

    async def get_recordingFilename(self):
        return self.data_in['recordingFilename']


class GetReplayBufferStatus(BaseRequests):
    """Get the status of the OBS replay buffer.

    Returns:
        isReplayBufferActive (bool): Current recording status.
    """

    def __init__(self):
        """Init."""

        super(GetReplayBufferStatus, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetReplayBufferStatus'
        self.data_in['isReplayBufferActive'] = None
        return self

    async def get_isReplayBufferActive(self):
        return self.data_in['isReplayBufferActive']


class GetSceneItemList(BaseRequests):
    """Get a list of all scene items in a scene.

    Args:
        sceneName (str) optional: Name of the scene to get the list of scene items from. Defaults to the current scene if not specified.

    Returns:
        sceneItems (list): Array of scene items
        sceneItems.*.itemId (int): Unique item id of the source item
        sceneItems.*.sourceKind (str): ID if the scene item's source. For example `vlc_source` or `image_source`
        sceneItems.*.sourceName (str): Name of the scene item's source
        sceneItems.*.sourceType (str): Type of the scene item's source. Either `input`, `group`, or `scene`
        sceneName (str): Name of the requested (or current) scene
    """

    def __init__(self):
        """Init."""

        super(GetSceneItemList, self).__init__()

    async def init(self, sceneName: Optional[str] = None):
        """Async init."""

        self.name = 'GetSceneItemList'
        self.data_in['sceneItems'] = None
        self.data_in['sceneItems.*.itemId'] = None
        self.data_in['sceneItems.*.sourceKind'] = None
        self.data_in['sceneItems.*.sourceName'] = None
        self.data_in['sceneItems.*.sourceType'] = None
        self.data_in['sceneName'] = None
        self.data_out['sceneName'] = sceneName
        return self

    async def get_sceneItems(self):
        return self.data_in['sceneItems']

    async def get_sceneItems___itemId(self):
        return self.data_in['sceneItems.*.itemId']

    async def get_sceneItems___sourceKind(self):
        return self.data_in['sceneItems.*.sourceKind']

    async def get_sceneItems___sourceName(self):
        return self.data_in['sceneItems.*.sourceName']

    async def get_sceneItems___sourceType(self):
        return self.data_in['sceneItems.*.sourceType']

    async def get_sceneName(self):
        return self.data_in['sceneName']


class GetSceneItemProperties(BaseRequests):
    """Gets the scene specific properties of the specified source item.
    Coordinates are relative to the item's parent (the scene or group it belongs to).

        Args:
            item (str | object): Scene Item name (if this field is a string) or specification (if it is an object).
            item.id (int) optional: Scene Item ID (if the `item` field is an object)
            item.name (str) optional: Scene Item name (if the `item` field is an object)
            scene-name (str) optional: Name of the scene the scene item belongs to. Defaults to the current scene.

        Returns:
            bounds.alignment (int): Alignment of the bounding box.
            bounds.type (str): Type of bounding box. Can be "OBS_BOUNDS_STRETCH", "OBS_BOUNDS_SCALE_INNER", "OBS_BOUNDS_SCALE_OUTER", "OBS_BOUNDS_SCALE_TO_WIDTH", "OBS_BOUNDS_SCALE_TO_HEIGHT", "OBS_BOUNDS_MAX_ONLY" or "OBS_BOUNDS_NONE".
            bounds.x (int): Width of the bounding box.
            bounds.y (int): Height of the bounding box.
            crop.bottom (int): The number of pixels cropped off the bottom of the source before scaling.
            crop.left (int): The number of pixels cropped off the left of the source before scaling.
            crop.right (int): The number of pixels cropped off the right of the source before scaling.
            crop.top (int): The number of pixels cropped off the top of the source before scaling.
            groupChildren (list): List of children (if this item is a group)
            height (int): Scene item height (base source height multiplied by the vertical scaling factor)
            itemId (int): Scene Item ID.
            locked (bool): If the source's transform is locked.
            muted (bool): If the source is muted.
            name (str): Scene Item name.
            parentGroupName (str): Name of the item's parent (if this item belongs to a group)
            position.alignment (int): The point on the source that the item is manipulated from. The sum of 1=Left or 2=Right, and 4=Top or 8=Bottom, or omit to center on that axis.
            position.x (int): The x position of the source from the left.
            position.y (int): The y position of the source from the top.
            rotation (int): The clockwise rotation of the item in degrees around the point of alignment.
            scale.filter (str): The scale filter of the source. Can be "OBS_SCALE_DISABLE", "OBS_SCALE_POINT", "OBS_SCALE_BICUBIC", "OBS_SCALE_BILINEAR", "OBS_SCALE_LANCZOS" or "OBS_SCALE_AREA".
            scale.x (int): The x-scale factor of the source.
            scale.y (int): The y-scale factor of the source.
            sourceHeight (int): Base source (without scaling) of the source
            sourceWidth (int): Base width (without scaling) of the source
            visible (bool): If the source is visible.
            width (int): Scene item width (base source width multiplied by the horizontal scaling factor)
    """

    def __init__(self):
        """Init."""

        super(GetSceneItemProperties, self).__init__()

    async def init(
        self,
        item: str,
        item_id: Optional[int] = None,
        item_name: Optional[str] = None,
        scene_name: Optional[str] = None,
    ):
        """Async init."""

        self.name = 'GetSceneItemProperties'
        self.data_in['bounds.alignment'] = None
        self.data_in['bounds.type'] = None
        self.data_in['bounds.x'] = None
        self.data_in['bounds.y'] = None
        self.data_in['crop.bottom'] = None
        self.data_in['crop.left'] = None
        self.data_in['crop.right'] = None
        self.data_in['crop.top'] = None
        self.data_in['groupChildren'] = None
        self.data_in['height'] = None
        self.data_in['itemId'] = None
        self.data_in['locked'] = None
        self.data_in['muted'] = None
        self.data_in['name'] = None
        self.data_in['parentGroupName'] = None
        self.data_in['position.alignment'] = None
        self.data_in['position.x'] = None
        self.data_in['position.y'] = None
        self.data_in['rotation'] = None
        self.data_in['scale.filter'] = None
        self.data_in['scale.x'] = None
        self.data_in['scale.y'] = None
        self.data_in['sourceHeight'] = None
        self.data_in['sourceWidth'] = None
        self.data_in['visible'] = None
        self.data_in['width'] = None
        self.data_out['item'] = item
        self.data_out['item.id'] = item_id
        self.data_out['item.name'] = item_name
        self.data_out['scene-name'] = scene_name
        return self

    async def get_bounds_alignment(self):
        return self.data_in['bounds.alignment']

    async def get_bounds_type(self):
        return self.data_in['bounds.type']

    async def get_bounds_x(self):
        return self.data_in['bounds.x']

    async def get_bounds_y(self):
        return self.data_in['bounds.y']

    async def get_crop_bottom(self):
        return self.data_in['crop.bottom']

    async def get_crop_left(self):
        return self.data_in['crop.left']

    async def get_crop_right(self):
        return self.data_in['crop.right']

    async def get_crop_top(self):
        return self.data_in['crop.top']

    async def get_groupChildren(self):
        return self.data_in['groupChildren']

    async def get_height(self):
        return self.data_in['height']

    async def get_itemId(self):
        return self.data_in['itemId']

    async def get_locked(self):
        return self.data_in['locked']

    async def get_muted(self):
        return self.data_in['muted']

    async def get_name(self):
        return self.data_in['name']

    async def get_parentGroupName(self):
        return self.data_in['parentGroupName']

    async def get_position_alignment(self):
        return self.data_in['position.alignment']

    async def get_position_x(self):
        return self.data_in['position.x']

    async def get_position_y(self):
        return self.data_in['position.y']

    async def get_rotation(self):
        return self.data_in['rotation']

    async def get_scale_filter(self):
        return self.data_in['scale.filter']

    async def get_scale_x(self):
        return self.data_in['scale.x']

    async def get_scale_y(self):
        return self.data_in['scale.y']

    async def get_sourceHeight(self):
        return self.data_in['sourceHeight']

    async def get_sourceWidth(self):
        return self.data_in['sourceWidth']

    async def get_visible(self):
        return self.data_in['visible']

    async def get_width(self):
        return self.data_in['width']


class GetSceneList(BaseRequests):
    """Get a list of scenes in the currently active profile.

    Returns:
        current-scene (str): Name of the currently active scene.
        scenes (list): Ordered list of the current profile's scenes (See [GetCurrentScene](#getcurrentscene) for more information).
    """

    def __init__(self):
        """Init."""

        super(GetSceneList, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetSceneList'
        self.data_in['current-scene'] = None
        self.data_in['scenes'] = None
        return self

    async def get_current_scene(self):
        return self.data_in['current-scene']

    async def get_scenes(self):
        return self.data_in['scenes']


class GetSceneTransitionOverride(BaseRequests):
    """Get the current scene transition override.

    Args:
        sceneName (str): Name of the scene to switch to.

    Returns:
        transitionDuration (int): Transition duration. `-1` if no override is set.
        transitionName (str): Name of the current overriding transition. Empty string if no override is set.
    """

    def __init__(self):
        """Init."""

        super(GetSceneTransitionOverride, self).__init__()

    async def init(self, sceneName: str):
        """Async init."""

        self.name = 'GetSceneTransitionOverride'
        self.data_in['transitionDuration'] = None
        self.data_in['transitionName'] = None
        self.data_out['sceneName'] = sceneName
        return self

    async def get_transitionDuration(self):
        return self.data_in['transitionDuration']

    async def get_transitionName(self):
        return self.data_in['transitionName']


class GetSourceActive(BaseRequests):
    """Get the source's active status of a specified source (if it is showing in the final mix).

    Args:
        sourceName (str): Source name.

    Returns:
        sourceActive (bool): Source active status of the source.
    """

    def __init__(self):
        """Init."""

        super(GetSourceActive, self).__init__()

    async def init(self, sourceName: str):
        """Async init."""

        self.name = 'GetSourceActive'
        self.data_in['sourceActive'] = None
        self.data_out['sourceName'] = sourceName
        return self

    async def get_sourceActive(self):
        return self.data_in['sourceActive']


class GetSourceDefaultSettings(BaseRequests):
    """Get the default settings for a given source type.

    Args:
        sourceKind (str): Source kind. Also called "source id" in libobs terminology.

    Returns:
        defaultSettings (object): Settings object for source.
        sourceKind (str): Source kind. Same value as the `sourceKind` parameter.
    """

    def __init__(self):
        """Init."""

        super(GetSourceDefaultSettings, self).__init__()

    async def init(self, sourceKind: str):
        """Async init."""

        self.name = 'GetSourceDefaultSettings'
        self.data_in['defaultSettings'] = None
        self.data_in['sourceKind'] = None
        self.data_out['sourceKind'] = sourceKind
        return self

    async def get_defaultSettings(self):
        return self.data_in['defaultSettings']

    async def get_sourceKind(self):
        return self.data_in['sourceKind']


class GetSourceFilterInfo(BaseRequests):
    """List filters applied to a source

    Args:
        filterName (str): Source filter name
        sourceName (str): Source name

    Returns:
        enabled (bool): Filter status (enabled or not)
        name (str): Filter name
        settings (object): Filter settings
        type (str): Filter type
    """

    def __init__(self):
        """Init."""

        super(GetSourceFilterInfo, self).__init__()

    async def init(self, filterName: str, sourceName: str):
        """Async init."""

        self.name = 'GetSourceFilterInfo'
        self.data_in['enabled'] = None
        self.data_in['name'] = None
        self.data_in['settings'] = None
        self.data_in['type'] = None
        self.data_out['filterName'] = filterName
        self.data_out['sourceName'] = sourceName
        return self

    async def get_enabled(self):
        return self.data_in['enabled']

    async def get_name(self):
        return self.data_in['name']

    async def get_settings(self):
        return self.data_in['settings']

    async def get_type(self):
        return self.data_in['type']


class GetSourceFilters(BaseRequests):
    """List filters applied to a source

    Args:
        sourceName (str): Source name

    Returns:
        filters (list): List of filters for the specified source
        filters.*.enabled (bool): Filter status (enabled or not)
        filters.*.name (str): Filter name
        filters.*.settings (object): Filter settings
        filters.*.type (str): Filter type
    """

    def __init__(self):
        """Init."""

        super(GetSourceFilters, self).__init__()

    async def init(self, sourceName: str):
        """Async init."""

        self.name = 'GetSourceFilters'
        self.data_in['filters'] = None
        self.data_in['filters.*.enabled'] = None
        self.data_in['filters.*.name'] = None
        self.data_in['filters.*.settings'] = None
        self.data_in['filters.*.type'] = None
        self.data_out['sourceName'] = sourceName
        return self

    async def get_filters(self):
        return self.data_in['filters']

    async def get_filters___enabled(self):
        return self.data_in['filters.*.enabled']

    async def get_filters___name(self):
        return self.data_in['filters.*.name']

    async def get_filters___settings(self):
        return self.data_in['filters.*.settings']

    async def get_filters___type(self):
        return self.data_in['filters.*.type']


class GetSourceSettings(BaseRequests):
    """Get settings of the specified source

    Args:
        sourceName (str): Source name.
        sourceType (str) optional: Type of the specified source. Useful for type-checking if you expect a specific settings schema.

    Returns:
        sourceName (str): Source name
        sourceSettings (object): Source settings (varies between source types, may require some probing around).
        sourceType (str): Type of the specified source
    """

    def __init__(self):
        """Init."""

        super(GetSourceSettings, self).__init__()

    async def init(self, sourceName: str, sourceType: Optional[str] = None):
        """Async init."""

        self.name = 'GetSourceSettings'
        self.data_in['sourceName'] = None
        self.data_in['sourceSettings'] = None
        self.data_in['sourceType'] = None
        self.data_out['sourceName'] = sourceName
        self.data_out['sourceType'] = sourceType
        return self

    async def get_sourceName(self):
        return self.data_in['sourceName']

    async def get_sourceSettings(self):
        return self.data_in['sourceSettings']

    async def get_sourceType(self):
        return self.data_in['sourceType']


class GetSourceTypesList(BaseRequests):
    """Get a list of all available sources types

    Returns:
        types (list): Array of source types
        types.*.caps (object): Source type capabilities
        types.*.caps.canInteract (bool): True if interaction with this sources of this type is possible
        types.*.caps.doNotDuplicate (bool): True if sources of this type should not be fully duplicated
        types.*.caps.doNotSelfMonitor (bool): True if sources of this type may cause a feedback loop if it's audio is monitored and shouldn't be
        types.*.caps.hasAudio (bool): True if sources of this type provide audio
        types.*.caps.hasVideo (bool): True if sources of this type provide video
        types.*.caps.isAsync (bool): True if source of this type provide frames asynchronously
        types.*.caps.isComposite (bool): True if sources of this type composite one or more sub-sources
        types.*.defaultSettings (object): Default settings of this source type
        types.*.displayName (str): Display name of the source type
        types.*.type (str): Type. Value is one of the following: "input", "filter", "transition" or "other"
        types.*.typeId (str): Non-unique internal source type ID
    """

    def __init__(self):
        """Init."""

        super(GetSourceTypesList, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetSourceTypesList'
        self.data_in['types'] = None
        self.data_in['types.*.caps'] = None
        self.data_in['types.*.caps.canInteract'] = None
        self.data_in['types.*.caps.doNotDuplicate'] = None
        self.data_in['types.*.caps.doNotSelfMonitor'] = None
        self.data_in['types.*.caps.hasAudio'] = None
        self.data_in['types.*.caps.hasVideo'] = None
        self.data_in['types.*.caps.isAsync'] = None
        self.data_in['types.*.caps.isComposite'] = None
        self.data_in['types.*.defaultSettings'] = None
        self.data_in['types.*.displayName'] = None
        self.data_in['types.*.type'] = None
        self.data_in['types.*.typeId'] = None
        return self

    async def get_types(self):
        return self.data_in['types']

    async def get_types___caps(self):
        return self.data_in['types.*.caps']

    async def get_types___caps_canInteract(self):
        return self.data_in['types.*.caps.canInteract']

    async def get_types___caps_doNotDuplicate(self):
        return self.data_in['types.*.caps.doNotDuplicate']

    async def get_types___caps_doNotSelfMonitor(self):
        return self.data_in['types.*.caps.doNotSelfMonitor']

    async def get_types___caps_hasAudio(self):
        return self.data_in['types.*.caps.hasAudio']

    async def get_types___caps_hasVideo(self):
        return self.data_in['types.*.caps.hasVideo']

    async def get_types___caps_isAsync(self):
        return self.data_in['types.*.caps.isAsync']

    async def get_types___caps_isComposite(self):
        return self.data_in['types.*.caps.isComposite']

    async def get_types___defaultSettings(self):
        return self.data_in['types.*.defaultSettings']

    async def get_types___displayName(self):
        return self.data_in['types.*.displayName']

    async def get_types___type(self):
        return self.data_in['types.*.type']

    async def get_types___typeId(self):
        return self.data_in['types.*.typeId']


class GetSourcesList(BaseRequests):
    """List all sources available in the running OBS instance

    Returns:
        sources (list): Array of sources
        sources.*.name (str): Unique source name
        sources.*.type (str): Source type. Value is one of the following: "input", "filter", "transition", "scene" or "unknown"
        sources.*.typeId (str): Non-unique source internal type (a.k.a kind)
    """

    def __init__(self):
        """Init."""

        super(GetSourcesList, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetSourcesList'
        self.data_in['sources'] = None
        self.data_in['sources.*.name'] = None
        self.data_in['sources.*.type'] = None
        self.data_in['sources.*.typeId'] = None
        return self

    async def get_sources(self):
        return self.data_in['sources']

    async def get_sources___name(self):
        return self.data_in['sources.*.name']

    async def get_sources___type(self):
        return self.data_in['sources.*.type']

    async def get_sources___typeId(self):
        return self.data_in['sources.*.typeId']


class GetSpecialSources(BaseRequests):
    """Get configured special sources like Desktop Audio and Mic/Aux sources.

    Returns:
        desktop-1 (str): Name of the first Desktop Audio capture source.
        desktop-2 (str): Name of the second Desktop Audio capture source.
        mic-1 (str): Name of the first Mic/Aux input source.
        mic-2 (str): Name of the second Mic/Aux input source.
        mic-3 (str): NAme of the third Mic/Aux input source.
    """

    def __init__(self):
        """Init."""

        super(GetSpecialSources, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetSpecialSources'
        self.data_in['desktop-1'] = None
        self.data_in['desktop-2'] = None
        self.data_in['mic-1'] = None
        self.data_in['mic-2'] = None
        self.data_in['mic-3'] = None
        return self

    async def get_desktop_1(self):
        return self.data_in['desktop-1']

    async def get_desktop_2(self):
        return self.data_in['desktop-2']

    async def get_mic_1(self):
        return self.data_in['mic-1']

    async def get_mic_2(self):
        return self.data_in['mic-2']

    async def get_mic_3(self):
        return self.data_in['mic-3']


class GetStats(BaseRequests):
    """Get OBS stats (almost the same info as provided in OBS' stats window)

    Returns:
        stats (OBSStats): [OBS stats](#obsstats)
    """

    def __init__(self):
        """Init."""

        super(GetStats, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetStats'
        self.data_in['stats'] = None
        return self

    async def get_stats(self):
        return self.data_in['stats']


class GetStreamSettings(BaseRequests):
    """Get the current streaming server settings.

    Returns:
        settings (object): Stream settings object.
        settings.key (str): The publish key of the stream.
        settings.password (str): The password to use when accessing the streaming server. Only present if `use_auth` is `true`.
        settings.server (str): The publish URL.
        settings.use_auth (bool): Indicates whether authentication should be used when connecting to the streaming server.
        settings.username (str): The username to use when accessing the streaming server. Only present if `use_auth` is `true`.
        type (str): The type of streaming service configuration. Possible values: 'rtmp_custom' or 'rtmp_common'.
    """

    def __init__(self):
        """Init."""

        super(GetStreamSettings, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetStreamSettings'
        self.data_in['settings'] = None
        self.data_in['settings.key'] = None
        self.data_in['settings.password'] = None
        self.data_in['settings.server'] = None
        self.data_in['settings.use_auth'] = None
        self.data_in['settings.username'] = None
        self.data_in['type'] = None
        return self

    async def get_settings(self):
        return self.data_in['settings']

    async def get_settings_key(self):
        return self.data_in['settings.key']

    async def get_settings_password(self):
        return self.data_in['settings.password']

    async def get_settings_server(self):
        return self.data_in['settings.server']

    async def get_settings_use_auth(self):
        return self.data_in['settings.use_auth']

    async def get_settings_username(self):
        return self.data_in['settings.username']

    async def get_type(self):
        return self.data_in['type']


class GetStreamingStatus(BaseRequests):
    """Get current streaming and recording status.

    Returns:
        preview-only (bool): Always false. Retrocompatibility with OBSRemote.
        rec-timecode (str): Time elapsed since recording started (only present if currently recording).
        recording (bool): Current recording status.
        recording-paused (bool): If recording is paused.
        stream-timecode (str): Time elapsed since streaming started (only present if currently streaming).
        streaming (bool): Current streaming status.
        virtualcam (bool): Current virtual cam status.
        virtualcam-timecode (str): Time elapsed since virtual cam started (only present if virtual cam currently active).
    """

    def __init__(self):
        """Init."""

        super(GetStreamingStatus, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetStreamingStatus'
        self.data_in['preview-only'] = None
        self.data_in['rec-timecode'] = None
        self.data_in['recording'] = None
        self.data_in['recording-paused'] = None
        self.data_in['stream-timecode'] = None
        self.data_in['streaming'] = None
        self.data_in['virtualcam'] = None
        self.data_in['virtualcam-timecode'] = None
        return self

    async def get_preview_only(self):
        return self.data_in['preview-only']

    async def get_rec_timecode(self):
        return self.data_in['rec-timecode']

    async def get_recording(self):
        return self.data_in['recording']

    async def get_recording_paused(self):
        return self.data_in['recording-paused']

    async def get_stream_timecode(self):
        return self.data_in['stream-timecode']

    async def get_streaming(self):
        return self.data_in['streaming']

    async def get_virtualcam(self):
        return self.data_in['virtualcam']

    async def get_virtualcam_timecode(self):
        return self.data_in['virtualcam-timecode']


class GetStudioModeStatus(BaseRequests):
    """Indicates if Studio Mode is currently enabled.

    Returns:
        studio-mode (bool): Indicates if Studio Mode is enabled.
    """

    def __init__(self):
        """Init."""

        super(GetStudioModeStatus, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetStudioModeStatus'
        self.data_in['studio-mode'] = None
        return self

    async def get_studio_mode(self):
        return self.data_in['studio-mode']


class GetSyncOffset(BaseRequests):
    """Get the audio sync offset of a specified source.

    Args:
        source (str): Source name.

    Returns:
        name (str): Source name.
        offset (int): The audio sync offset (in nanoseconds).
    """

    def __init__(self):
        """Init."""

        super(GetSyncOffset, self).__init__()

    async def init(self, source: str):
        """Async init."""

        self.name = 'GetSyncOffset'
        self.data_in['name'] = None
        self.data_in['offset'] = None
        self.data_out['source'] = source
        return self

    async def get_name(self):
        return self.data_in['name']

    async def get_offset(self):
        return self.data_in['offset']


class GetTextFreetype2Properties(BaseRequests):
    """Get the current properties of a Text Freetype 2 source.

    Args:
        source (str): Source name.

    Returns:
        color1 (int): Gradient top color.
        color2 (int): Gradient bottom color.
        custom_width (int): Custom width (0 to disable).
        drop_shadow (bool): Drop shadow.
        font (object): Holds data for the font. Ex: `"font": { "face": "Arial", "flags": 0, "size": 150, "style": "" }`
        font.face (str): Font face.
        font.flags (int): Font text styling flag. `Bold=1, Italic=2, Bold Italic=3, Underline=5, Strikeout=8`
        font.size (int): Font text size.
        font.style (str): Font Style (unknown function).
        from_file (bool): Read text from the specified file.
        log_mode (bool): Chat log.
        outline (bool): Outline.
        source (str): Source name
        text (str): Text content to be displayed.
        text_file (str): File path.
        word_wrap (bool): Word wrap.
    """

    def __init__(self):
        """Init."""

        super(GetTextFreetype2Properties, self).__init__()

    async def init(self, source: str):
        """Async init."""

        self.name = 'GetTextFreetype2Properties'
        self.data_in['color1'] = None
        self.data_in['color2'] = None
        self.data_in['custom_width'] = None
        self.data_in['drop_shadow'] = None
        self.data_in['font'] = None
        self.data_in['font.face'] = None
        self.data_in['font.flags'] = None
        self.data_in['font.size'] = None
        self.data_in['font.style'] = None
        self.data_in['from_file'] = None
        self.data_in['log_mode'] = None
        self.data_in['outline'] = None
        self.data_in['source'] = None
        self.data_in['text'] = None
        self.data_in['text_file'] = None
        self.data_in['word_wrap'] = None
        self.data_out['source'] = source
        return self

    async def get_color1(self):
        return self.data_in['color1']

    async def get_color2(self):
        return self.data_in['color2']

    async def get_custom_width(self):
        return self.data_in['custom_width']

    async def get_drop_shadow(self):
        return self.data_in['drop_shadow']

    async def get_font(self):
        return self.data_in['font']

    async def get_font_face(self):
        return self.data_in['font.face']

    async def get_font_flags(self):
        return self.data_in['font.flags']

    async def get_font_size(self):
        return self.data_in['font.size']

    async def get_font_style(self):
        return self.data_in['font.style']

    async def get_from_file(self):
        return self.data_in['from_file']

    async def get_log_mode(self):
        return self.data_in['log_mode']

    async def get_outline(self):
        return self.data_in['outline']

    async def get_source(self):
        return self.data_in['source']

    async def get_text(self):
        return self.data_in['text']

    async def get_text_file(self):
        return self.data_in['text_file']

    async def get_word_wrap(self):
        return self.data_in['word_wrap']


class GetTextGDIPlusProperties(BaseRequests):
    """Get the current properties of a Text GDI Plus source.

    Args:
        source (str): Source name.

    Returns:
        align (str): Text Alignment ("left", "center", "right").
        bk_color (int): Background color.
        bk_opacity (int): Background opacity (0-100).
        chatlog (bool): Chat log.
        chatlog_lines (int): Chat log lines.
        color (int): Text color.
        extents (bool): Extents wrap.
        extents_cx (int): Extents cx.
        extents_cy (int): Extents cy.
        file (str): File path name.
        font (object): Holds data for the font. Ex: `"font": { "face": "Arial", "flags": 0, "size": 150, "style": "" }`
        font.face (str): Font face.
        font.flags (int): Font text styling flag. `Bold=1, Italic=2, Bold Italic=3, Underline=5, Strikeout=8`
        font.size (int): Font text size.
        font.style (str): Font Style (unknown function).
        gradient (bool): Gradient enabled.
        gradient_color (int): Gradient color.
        gradient_dir (float): Gradient direction.
        gradient_opacity (int): Gradient opacity (0-100).
        outline (bool): Outline.
        outline_color (int): Outline color.
        outline_opacity (int): Outline opacity (0-100).
        outline_size (int): Outline size.
        read_from_file (bool): Read text from the specified file.
        source (str): Source name.
        text (str): Text content to be displayed.
        valign (str): Text vertical alignment ("top", "center", "bottom").
        vertical (bool): Vertical text enabled.
    """

    def __init__(self):
        """Init."""

        super(GetTextGDIPlusProperties, self).__init__()

    async def init(self, source: str):
        """Async init."""

        self.name = 'GetTextGDIPlusProperties'
        self.data_in['align'] = None
        self.data_in['bk_color'] = None
        self.data_in['bk_opacity'] = None
        self.data_in['chatlog'] = None
        self.data_in['chatlog_lines'] = None
        self.data_in['color'] = None
        self.data_in['extents'] = None
        self.data_in['extents_cx'] = None
        self.data_in['extents_cy'] = None
        self.data_in['file'] = None
        self.data_in['font'] = None
        self.data_in['font.face'] = None
        self.data_in['font.flags'] = None
        self.data_in['font.size'] = None
        self.data_in['font.style'] = None
        self.data_in['gradient'] = None
        self.data_in['gradient_color'] = None
        self.data_in['gradient_dir'] = None
        self.data_in['gradient_opacity'] = None
        self.data_in['outline'] = None
        self.data_in['outline_color'] = None
        self.data_in['outline_opacity'] = None
        self.data_in['outline_size'] = None
        self.data_in['read_from_file'] = None
        self.data_in['source'] = None
        self.data_in['text'] = None
        self.data_in['valign'] = None
        self.data_in['vertical'] = None
        self.data_out['source'] = source
        return self

    async def get_align(self):
        return self.data_in['align']

    async def get_bk_color(self):
        return self.data_in['bk_color']

    async def get_bk_opacity(self):
        return self.data_in['bk_opacity']

    async def get_chatlog(self):
        return self.data_in['chatlog']

    async def get_chatlog_lines(self):
        return self.data_in['chatlog_lines']

    async def get_color(self):
        return self.data_in['color']

    async def get_extents(self):
        return self.data_in['extents']

    async def get_extents_cx(self):
        return self.data_in['extents_cx']

    async def get_extents_cy(self):
        return self.data_in['extents_cy']

    async def get_file(self):
        return self.data_in['file']

    async def get_font(self):
        return self.data_in['font']

    async def get_font_face(self):
        return self.data_in['font.face']

    async def get_font_flags(self):
        return self.data_in['font.flags']

    async def get_font_size(self):
        return self.data_in['font.size']

    async def get_font_style(self):
        return self.data_in['font.style']

    async def get_gradient(self):
        return self.data_in['gradient']

    async def get_gradient_color(self):
        return self.data_in['gradient_color']

    async def get_gradient_dir(self):
        return self.data_in['gradient_dir']

    async def get_gradient_opacity(self):
        return self.data_in['gradient_opacity']

    async def get_outline(self):
        return self.data_in['outline']

    async def get_outline_color(self):
        return self.data_in['outline_color']

    async def get_outline_opacity(self):
        return self.data_in['outline_opacity']

    async def get_outline_size(self):
        return self.data_in['outline_size']

    async def get_read_from_file(self):
        return self.data_in['read_from_file']

    async def get_source(self):
        return self.data_in['source']

    async def get_text(self):
        return self.data_in['text']

    async def get_valign(self):
        return self.data_in['valign']

    async def get_vertical(self):
        return self.data_in['vertical']


class GetTransitionDuration(BaseRequests):
    """Get the duration of the currently selected transition if supported.

    Returns:
        transition-duration (int): Duration of the current transition (in milliseconds).
    """

    def __init__(self):
        """Init."""

        super(GetTransitionDuration, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetTransitionDuration'
        self.data_in['transition-duration'] = None
        return self

    async def get_transition_duration(self):
        return self.data_in['transition-duration']


class GetTransitionList(BaseRequests):
    """List of all transitions available in the frontend's dropdown menu.

    Returns:
        current-transition (str): Name of the currently active transition.
        transitions (list): List of transitions.
        transitions.*.name (str): Name of the transition.
    """

    def __init__(self):
        """Init."""

        super(GetTransitionList, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetTransitionList'
        self.data_in['current-transition'] = None
        self.data_in['transitions'] = None
        self.data_in['transitions.*.name'] = None
        return self

    async def get_current_transition(self):
        return self.data_in['current-transition']

    async def get_transitions(self):
        return self.data_in['transitions']

    async def get_transitions___name(self):
        return self.data_in['transitions.*.name']


class GetTransitionPosition(BaseRequests):
    """Get the position of the current transition.

    Returns:
        position (int): current transition position. This value will be between 0.0 and 1.0. Note: Transition returns 1.0 when not active.
    """

    def __init__(self):
        """Init."""

        super(GetTransitionPosition, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetTransitionPosition'
        self.data_in['position'] = None
        return self

    async def get_position(self):
        return self.data_in['position']


class GetTransitionSettings(BaseRequests):
    """Get the current settings of a transition

    Args:
        transitionName (str): Transition name

    Returns:
        transitionSettings (object): Current transition settings
    """

    def __init__(self):
        """Init."""

        super(GetTransitionSettings, self).__init__()

    async def init(self, transitionName: str):
        """Async init."""

        self.name = 'GetTransitionSettings'
        self.data_in['transitionSettings'] = None
        self.data_out['transitionName'] = transitionName
        return self

    async def get_transitionSettings(self):
        return self.data_in['transitionSettings']


class GetVersion(BaseRequests):
    """Returns the latest version of the plugin and the API.

    Returns:
        available-requests (str): List of available request types, formatted as a comma-separated list string (e.g. : "Method1,Method2,Method3").
        obs-studio-version (str): OBS Studio program version.
        obs-websocket-version (str): obs-websocket plugin version.
        supported-image-export-formats (str): List of supported formats for features that use image export (like the TakeSourceScreenshot request type) formatted as a comma-separated list string
        version (int): OBSRemote compatible API version. Fixed to 1.1 for retrocompatibility.
    """

    def __init__(self):
        """Init."""

        super(GetVersion, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetVersion'
        self.data_in['available-requests'] = None
        self.data_in['obs-studio-version'] = None
        self.data_in['obs-websocket-version'] = None
        self.data_in['supported-image-export-formats'] = None
        self.data_in['version'] = None
        return self

    async def get_available_requests(self):
        return self.data_in['available-requests']

    async def get_obs_studio_version(self):
        return self.data_in['obs-studio-version']

    async def get_obs_websocket_version(self):
        return self.data_in['obs-websocket-version']

    async def get_supported_image_export_formats(self):
        return self.data_in['supported-image-export-formats']

    async def get_version(self):
        return self.data_in['version']


class GetVideoInfo(BaseRequests):
    """Get basic OBS video information

    Returns:
        baseHeight (int): Base (canvas) height
        baseWidth (int): Base (canvas) width
        colorRange (str): Color range (full or partial)
        colorSpace (str): Color space for YUV
        fps (int): Frames rendered per second
        outputHeight (int): Output height
        outputWidth (int): Output width
        scaleType (str): Scaling method used if output size differs from base size
        videoFormat (str): Video color format
    """

    def __init__(self):
        """Init."""

        super(GetVideoInfo, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetVideoInfo'
        self.data_in['baseHeight'] = None
        self.data_in['baseWidth'] = None
        self.data_in['colorRange'] = None
        self.data_in['colorSpace'] = None
        self.data_in['fps'] = None
        self.data_in['outputHeight'] = None
        self.data_in['outputWidth'] = None
        self.data_in['scaleType'] = None
        self.data_in['videoFormat'] = None
        return self

    async def get_baseHeight(self):
        return self.data_in['baseHeight']

    async def get_baseWidth(self):
        return self.data_in['baseWidth']

    async def get_colorRange(self):
        return self.data_in['colorRange']

    async def get_colorSpace(self):
        return self.data_in['colorSpace']

    async def get_fps(self):
        return self.data_in['fps']

    async def get_outputHeight(self):
        return self.data_in['outputHeight']

    async def get_outputWidth(self):
        return self.data_in['outputWidth']

    async def get_scaleType(self):
        return self.data_in['scaleType']

    async def get_videoFormat(self):
        return self.data_in['videoFormat']


class GetVirtualCamStatus(BaseRequests):
    """Get current virtual cam status.

    Returns:
        isVirtualCam (bool): Current virtual camera status.
        virtualCamTimecode (str): Time elapsed since virtual cam started (only present if virtual cam currently active).
    """

    def __init__(self):
        """Init."""

        super(GetVirtualCamStatus, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'GetVirtualCamStatus'
        self.data_in['isVirtualCam'] = None
        self.data_in['virtualCamTimecode'] = None
        return self

    async def get_isVirtualCam(self):
        return self.data_in['isVirtualCam']

    async def get_virtualCamTimecode(self):
        return self.data_in['virtualCamTimecode']


class GetVolume(BaseRequests):
    """Get the volume of the specified source. Default response uses mul format, NOT SLIDER PERCENTAGE.

    Args:
        source (str): Source name.
        useDecibel (bool) optional: Output volume in decibels of attenuation instead of amplitude/mul.

    Returns:
        muted (bool): Indicates whether the source is muted.
        name (str): Source name.
        volume (int): Volume of the source. Between `0.0` and `20.0` if using mul, under `26.0` if using dB.
    """

    def __init__(self):
        """Init."""

        super(GetVolume, self).__init__()

    async def init(self, source: str, useDecibel: Optional[bool] = None):
        """Async init."""

        self.name = 'GetVolume'
        self.data_in['muted'] = None
        self.data_in['name'] = None
        self.data_in['volume'] = None
        self.data_out['source'] = source
        self.data_out['useDecibel'] = useDecibel
        return self

    async def get_muted(self):
        return self.data_in['muted']

    async def get_name(self):
        return self.data_in['name']

    async def get_volume(self):
        return self.data_in['volume']


class ListOutputs(BaseRequests):
    """List existing outputs

    Returns:
        outputs (list): Outputs list
    """

    def __init__(self):
        """Init."""

        super(ListOutputs, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'ListOutputs'
        self.data_in['outputs'] = None
        return self

    async def get_outputs(self):
        return self.data_in['outputs']


class ListProfiles(BaseRequests):
    """Get a list of available profiles.

    Returns:
        profiles (list): List of available profiles.
        profiles.*.profile-name (str): Filter name
    """

    def __init__(self):
        """Init."""

        super(ListProfiles, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'ListProfiles'
        self.data_in['profiles'] = None
        self.data_in['profiles.*.profile-name'] = None
        return self

    async def get_profiles(self):
        return self.data_in['profiles']

    async def get_profiles___profile_name(self):
        return self.data_in['profiles.*.profile-name']


class ListSceneCollections(BaseRequests):
    """List available scene collections

    Returns:
        scene-collections (list): Scene collections list
    """

    def __init__(self):
        """Init."""

        super(ListSceneCollections, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'ListSceneCollections'
        self.data_in['scene-collections'] = None
        return self

    async def get_scene_collections(self):
        return self.data_in['scene-collections']


class MoveSourceFilter(BaseRequests):
    """Move a filter in the chain (relative positioning)

    Args:
        filterName (str): Name of the filter to reorder
        movementType (str): How to move the filter around in the source's filter chain. Either "up", "down", "top" or "bottom".
        sourceName (str): Name of the source to which the filter belongs
    """

    def __init__(self):
        """Init."""

        super(MoveSourceFilter, self).__init__()

    async def init(self, filterName: str, movementType: str, sourceName: str):
        """Async init."""

        self.name = 'MoveSourceFilter'
        self.data_out['filterName'] = filterName
        self.data_out['movementType'] = movementType
        self.data_out['sourceName'] = sourceName
        return self


class NextMedia(BaseRequests):
    """Skip to the next media item in the playlist. Supports only vlc media source (as of OBS v25.0.8)

    Args:
        sourceName (str): Source name.
    """

    def __init__(self):
        """Init."""

        super(NextMedia, self).__init__()

    async def init(self, sourceName: str):
        """Async init."""

        self.name = 'NextMedia'
        self.data_out['sourceName'] = sourceName
        return self


class OpenProjector(BaseRequests):
    """Open a projector window or create a projector on a monitor. Requires OBS v24.0.4 or newer.

    Args:
        geometry (str): Size and position of the projector window (only if monitor is -1). Encoded in Base64 using [Qt's geometry encoding](https://doc.qt.io/qt-5/qwidget.html#saveGeometry). Corresponds to OBS's saved projectors.
        monitor (int): Monitor to open the projector on. If -1 or omitted, opens a window.
        name (str): Name of the source or scene to be displayed (ignored for other projector types).
        type (str): Type of projector: `Preview` (default), `Source`, `Scene`, `StudioProgram`, or `Multiview` (case insensitive).
    """

    def __init__(self):
        """Init."""

        super(OpenProjector, self).__init__()

    async def init(self, geometry: str, monitor: int, name: str, type: str):
        """Async init."""

        self.name = 'OpenProjector'
        self.data_out['geometry'] = geometry
        self.data_out['monitor'] = monitor
        self.data_out['name'] = name
        self.data_out['type'] = type
        return self


class PauseRecording(BaseRequests):
    """Pause the current recording.
    Returns an error if recording is not active or already paused.
    """

    def __init__(self):
        """Init."""

        super(PauseRecording, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'PauseRecording'
        return self


class PlayPauseMedia(BaseRequests):
    """Pause or play a media source. Supports ffmpeg and vlc media sources (as of OBS v25.0.8)
    Note :Leaving out `playPause` toggles the current pause state

        Args:
            playPause (bool): (optional) Whether to pause or play the source. `false` for play, `true` for pause.
            sourceName (str): Source name.
    """

    def __init__(self):
        """Init."""

        super(PlayPauseMedia, self).__init__()

    async def init(self, playPause: bool, sourceName: str):
        """Async init."""

        self.name = 'PlayPauseMedia'
        self.data_out['playPause'] = playPause
        self.data_out['sourceName'] = sourceName
        return self


class PreviousMedia(BaseRequests):
    """Go to the previous media item in the playlist. Supports only vlc media source (as of OBS v25.0.8)

    Args:
        sourceName (str): Source name.
    """

    def __init__(self):
        """Init."""

        super(PreviousMedia, self).__init__()

    async def init(self, sourceName: str):
        """Async init."""

        self.name = 'PreviousMedia'
        self.data_out['sourceName'] = sourceName
        return self


class RefreshBrowserSource(BaseRequests):
    """Refreshes the specified browser source.

    Args:
        sourceName (str): Source name.
    """

    def __init__(self):
        """Init."""

        super(RefreshBrowserSource, self).__init__()

    async def init(self, sourceName: str):
        """Async init."""

        self.name = 'RefreshBrowserSource'
        self.data_out['sourceName'] = sourceName
        return self


class ReleaseTBar(BaseRequests):
    """Release the T-Bar (like a user releasing their mouse button after moving it).
    *YOU MUST CALL THIS if you called `SetTBarPosition` with the `release` parameter set to `false`.*
    """

    def __init__(self):
        """Init."""

        super(ReleaseTBar, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'ReleaseTBar'
        return self


class RemoveFilterFromSource(BaseRequests):
    """Remove a filter from a source

    Args:
        filterName (str): Name of the filter to remove
        sourceName (str): Name of the source from which the specified filter is removed
    """

    def __init__(self):
        """Init."""

        super(RemoveFilterFromSource, self).__init__()

    async def init(self, filterName: str, sourceName: str):
        """Async init."""

        self.name = 'RemoveFilterFromSource'
        self.data_out['filterName'] = filterName
        self.data_out['sourceName'] = sourceName
        return self


class RemoveSceneTransitionOverride(BaseRequests):
    """Remove any transition override on a scene.

    Args:
        sceneName (str): Name of the scene to switch to.
    """

    def __init__(self):
        """Init."""

        super(RemoveSceneTransitionOverride, self).__init__()

    async def init(self, sceneName: str):
        """Async init."""

        self.name = 'RemoveSceneTransitionOverride'
        self.data_out['sceneName'] = sceneName
        return self


class ReorderSceneItems(BaseRequests):
    """Changes the order of scene items in the requested scene.

    Args:
        items (list): Ordered list of objects with name and/or id specified. Id preferred due to uniqueness per scene
        items.*.id (int) optional: Id of a specific scene item. Unique on a scene by scene basis.
        items.*.name (str) optional: Name of a scene item. Sufficiently unique if no scene items share sources within the scene.
        scene (str) optional: Name of the scene to reorder (defaults to current).
    """

    def __init__(self):
        """Init."""

        super(ReorderSceneItems, self).__init__()

    async def init(
        self,
        items: list,
        items___id: Optional[int] = None,
        items___name: Optional[str] = None,
        scene: Optional[str] = None,
    ):
        """Async init."""

        self.name = 'ReorderSceneItems'
        self.data_out['items'] = items
        self.data_out['items.*.id'] = items___id
        self.data_out['items.*.name'] = items___name
        self.data_out['scene'] = scene
        return self


class ReorderSourceFilter(BaseRequests):
    """Move a filter in the chain (absolute index positioning)

    Args:
        filterName (str): Name of the filter to reorder
        newIndex (int): Desired position of the filter in the chain
        sourceName (str): Name of the source to which the filter belongs
    """

    def __init__(self):
        """Init."""

        super(ReorderSourceFilter, self).__init__()

    async def init(self, filterName: str, newIndex: int, sourceName: str):
        """Async init."""

        self.name = 'ReorderSourceFilter'
        self.data_out['filterName'] = filterName
        self.data_out['newIndex'] = newIndex
        self.data_out['sourceName'] = sourceName
        return self


class ResetSceneItem(BaseRequests):
    """Reset a scene item.

    Args:
        item (str | object): Scene Item name (if this field is a string) or specification (if it is an object).
        item.id (int) optional: Scene Item ID (if the `item` field is an object)
        item.name (str) optional: Scene Item name (if the `item` field is an object)
        scene-name (str) optional: Name of the scene the scene item belongs to. Defaults to the current scene.
    """

    def __init__(self):
        """Init."""

        super(ResetSceneItem, self).__init__()

    async def init(
        self,
        item: str,
        item_id: Optional[int] = None,
        item_name: Optional[str] = None,
        scene_name: Optional[str] = None,
    ):
        """Async init."""

        self.name = 'ResetSceneItem'
        self.data_out['item'] = item
        self.data_out['item.id'] = item_id
        self.data_out['item.name'] = item_name
        self.data_out['scene-name'] = scene_name
        return self


class RestartMedia(BaseRequests):
    """Restart a media source. Supports ffmpeg and vlc media sources (as of OBS v25.0.8)

    Args:
        sourceName (str): Source name.
    """

    def __init__(self):
        """Init."""

        super(RestartMedia, self).__init__()

    async def init(self, sourceName: str):
        """Async init."""

        self.name = 'RestartMedia'
        self.data_out['sourceName'] = sourceName
        return self


class ResumeRecording(BaseRequests):
    """Resume/unpause the current recording (if paused).
    Returns an error if recording is not active or not paused.
    """

    def __init__(self):
        """Init."""

        super(ResumeRecording, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'ResumeRecording'
        return self


class SaveReplayBuffer(BaseRequests):
    """Flush and save the contents of the Replay Buffer to disk. This is
    basically the same as triggering the "Save Replay Buffer" hotkey.
    Will return an `error` if the Replay Buffer is not active.
    """

    def __init__(self):
        """Init."""

        super(SaveReplayBuffer, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'SaveReplayBuffer'
        return self


class SaveStreamSettings(BaseRequests):
    """Save the current streaming server settings to disk."""

    def __init__(self):
        """Init."""

        super(SaveStreamSettings, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'SaveStreamSettings'
        return self


class ScrubMedia(BaseRequests):
    """Scrub media using a supplied offset. Supports ffmpeg and vlc media sources (as of OBS v25.0.8)
    Note: Due to processing/network delays, this request is not perfect. The processing rate of this request has also not been tested.

        Args:
            sourceName (str): Source name.
            timeOffset (int): Millisecond offset (positive or negative) to offset the current media position.
    """

    def __init__(self):
        """Init."""

        super(ScrubMedia, self).__init__()

    async def init(self, sourceName: str, timeOffset: int):
        """Async init."""

        self.name = 'ScrubMedia'
        self.data_out['sourceName'] = sourceName
        self.data_out['timeOffset'] = timeOffset
        return self


class SendCaptions(BaseRequests):
    """Send the provided text as embedded CEA-608 caption data.

    Args:
        text (str): Captions text
    """

    def __init__(self):
        """Init."""

        super(SendCaptions, self).__init__()

    async def init(self, text: str):
        """Async init."""

        self.name = 'SendCaptions'
        self.data_out['text'] = text
        return self


class SetAudioMonitorType(BaseRequests):
    """Set the audio monitoring type of the specified source.

    Args:
        monitorType (str): The monitor type to use. Options: `none`, `monitorOnly`, `monitorAndOutput`.
        sourceName (str): Source name.
    """

    def __init__(self):
        """Init."""

        super(SetAudioMonitorType, self).__init__()

    async def init(self, monitorType: str, sourceName: str):
        """Async init."""

        self.name = 'SetAudioMonitorType'
        self.data_out['monitorType'] = monitorType
        self.data_out['sourceName'] = sourceName
        return self


class SetAudioTracks(BaseRequests):
    """Changes whether an audio track is active for a source.

    Args:
        active (bool): Whether audio track is active or not.
        sourceName (str): Source name.
        track (int): Audio tracks 1-6.
    """

    def __init__(self):
        """Init."""

        super(SetAudioTracks, self).__init__()

    async def init(self, active: bool, sourceName: str, track: int):
        """Async init."""

        self.name = 'SetAudioTracks'
        self.data_out['active'] = active
        self.data_out['sourceName'] = sourceName
        self.data_out['track'] = track
        return self


class SetBrowserSourceProperties(BaseRequests):
    """Set current properties for a Browser Source.

    Args:
        source (str): Name of the source.
        css (str) optional: CSS to inject.
        fps (int) optional: Framerate.
        height (int) optional: Height.
        is_local_file (bool) optional: Indicates that a local file is in use.
        local_file (str) optional: file path.
        render (bool) optional: Visibility of the scene item.
        shutdown (bool) optional: Indicates whether the source should be shutdown when not visible.
        url (str) optional: Url.
        width (int) optional: Width.
    """

    def __init__(self):
        """Init."""

        super(SetBrowserSourceProperties, self).__init__()

    async def init(
        self,
        source: str,
        css: Optional[str] = None,
        fps: Optional[int] = None,
        height: Optional[int] = None,
        is_local_file: Optional[bool] = None,
        local_file: Optional[str] = None,
        render: Optional[bool] = None,
        shutdown: Optional[bool] = None,
        url: Optional[str] = None,
        width: Optional[int] = None,
    ):
        """Async init."""

        self.name = 'SetBrowserSourceProperties'
        self.data_out['source'] = source
        self.data_out['css'] = css
        self.data_out['fps'] = fps
        self.data_out['height'] = height
        self.data_out['is_local_file'] = is_local_file
        self.data_out['local_file'] = local_file
        self.data_out['render'] = render
        self.data_out['shutdown'] = shutdown
        self.data_out['url'] = url
        self.data_out['width'] = width
        return self


class SetCurrentProfile(BaseRequests):
    """Set the currently active profile.

    Args:
        profile-name (str): Name of the desired profile.
    """

    def __init__(self):
        """Init."""

        super(SetCurrentProfile, self).__init__()

    async def init(self, profile_name: str):
        """Async init."""

        self.name = 'SetCurrentProfile'
        self.data_out['profile-name'] = profile_name
        return self


class SetCurrentScene(BaseRequests):
    """Switch to the specified scene.

    Args:
        scene-name (str): Name of the scene to switch to.
    """

    def __init__(self):
        """Init."""

        super(SetCurrentScene, self).__init__()

    async def init(self, scene_name: str):
        """Async init."""

        self.name = 'SetCurrentScene'
        self.data_out['scene-name'] = scene_name
        return self


class SetCurrentSceneCollection(BaseRequests):
    """Change the active scene collection.

    Args:
        sc-name (str): Name of the desired scene collection.
    """

    def __init__(self):
        """Init."""

        super(SetCurrentSceneCollection, self).__init__()

    async def init(self, sc_name: str):
        """Async init."""

        self.name = 'SetCurrentSceneCollection'
        self.data_out['sc-name'] = sc_name
        return self


class SetCurrentTransition(BaseRequests):
    """Set the active transition.

    Args:
        transition-name (str): The name of the transition.
    """

    def __init__(self):
        """Init."""

        super(SetCurrentTransition, self).__init__()

    async def init(self, transition_name: str):
        """Async init."""

        self.name = 'SetCurrentTransition'
        self.data_out['transition-name'] = transition_name
        return self


class SetFilenameFormatting(BaseRequests):
    """Set the filename formatting string

    Args:
        filename-formatting (str): Filename formatting string to set.
    """

    def __init__(self):
        """Init."""

        super(SetFilenameFormatting, self).__init__()

    async def init(self, filename_formatting: str):
        """Async init."""

        self.name = 'SetFilenameFormatting'
        self.data_out['filename-formatting'] = filename_formatting
        return self


class SetHeartbeat(BaseRequests):
    """Enable/disable sending of the Heartbeat event

    Args:
        enable (bool): Starts/Stops emitting heartbeat messages
    """

    def __init__(self):
        """Init."""

        super(SetHeartbeat, self).__init__()

    async def init(self, enable: bool):
        """Async init."""

        self.name = 'SetHeartbeat'
        self.data_out['enable'] = enable
        return self


class SetMediaTime(BaseRequests):
    """Set the timestamp of a media source. Supports ffmpeg and vlc media sources (as of OBS v25.0.8)

    Args:
        sourceName (str): Source name.
        timestamp (int): Milliseconds to set the timestamp to.
    """

    def __init__(self):
        """Init."""

        super(SetMediaTime, self).__init__()

    async def init(self, sourceName: str, timestamp: int):
        """Async init."""

        self.name = 'SetMediaTime'
        self.data_out['sourceName'] = sourceName
        self.data_out['timestamp'] = timestamp
        return self


class SetMute(BaseRequests):
    """Sets the mute status of a specified source.

    Args:
        mute (bool): Desired mute status.
        source (str): Source name.
    """

    def __init__(self):
        """Init."""

        super(SetMute, self).__init__()

    async def init(self, mute: bool, source: str):
        """Async init."""

        self.name = 'SetMute'
        self.data_out['mute'] = mute
        self.data_out['source'] = source
        return self


class SetPreviewScene(BaseRequests):
    """Set the active preview scene.
    Will return an `error` if Studio Mode is not enabled.

        Args:
            scene-name (str): The name of the scene to preview.
    """

    def __init__(self):
        """Init."""

        super(SetPreviewScene, self).__init__()

    async def init(self, scene_name: str):
        """Async init."""

        self.name = 'SetPreviewScene'
        self.data_out['scene-name'] = scene_name
        return self


class SetRecordingFolder(BaseRequests):
    """Note: If `SetRecordingFolder` is called while a recording is
    in progress, the change won't be applied immediately and will be
    effective on the next recording.

        Args:
            rec-folder (str): Path of the recording folder.
    """

    def __init__(self):
        """Init."""

        super(SetRecordingFolder, self).__init__()

    async def init(self, rec_folder: str):
        """Async init."""

        self.name = 'SetRecordingFolder'
        self.data_out['rec-folder'] = rec_folder
        return self


class SetSceneItemCrop(BaseRequests):
    """Sets the crop coordinates of the specified source item.

    Args:
        bottom (int): Pixel position of the bottom of the source item.
        item (str): Scene Item name.
        left (int): Pixel position of the left of the source item.
        right (int): Pixel position of the right of the source item.
        top (int): Pixel position of the top of the source item.
        scene-name (str) optional: Name of the scene the scene item belongs to. Defaults to the current scene.
    """

    def __init__(self):
        """Init."""

        super(SetSceneItemCrop, self).__init__()

    async def init(
        self,
        bottom: int,
        item: str,
        left: int,
        right: int,
        top: int,
        scene_name: Optional[str] = None,
    ):
        """Async init."""

        self.name = 'SetSceneItemCrop'
        self.data_out['bottom'] = bottom
        self.data_out['item'] = item
        self.data_out['left'] = left
        self.data_out['right'] = right
        self.data_out['top'] = top
        self.data_out['scene-name'] = scene_name
        return self


class SetSceneItemPosition(BaseRequests):
    """Sets the coordinates of a specified source item.

    Args:
        item (str): Scene Item name.
        x (int): X coordinate.
        y (int): Y coordinate.
        scene-name (str) optional: Name of the scene the scene item belongs to. Defaults to the current scene.
    """

    def __init__(self):
        """Init."""

        super(SetSceneItemPosition, self).__init__()

    async def init(
        self, item: str, x: int, y: int, scene_name: Optional[str] = None
    ):
        """Async init."""

        self.name = 'SetSceneItemPosition'
        self.data_out['item'] = item
        self.data_out['x'] = x
        self.data_out['y'] = y
        self.data_out['scene-name'] = scene_name
        return self


class SetSceneItemProperties(BaseRequests):
    """Sets the scene specific properties of a source. Unspecified properties will remain unchanged.
    Coordinates are relative to the item's parent (the scene or group it belongs to).

        Args:
            item (str | object): Scene Item name (if this field is a string) or specification (if it is an object).
            bounds.alignment (int) optional: The new alignment of the bounding box. (0-2, 4-6, 8-10)
            bounds.type (str) optional: The new bounds type of the source. Can be "OBS_BOUNDS_STRETCH", "OBS_BOUNDS_SCALE_INNER", "OBS_BOUNDS_SCALE_OUTER", "OBS_BOUNDS_SCALE_TO_WIDTH", "OBS_BOUNDS_SCALE_TO_HEIGHT", "OBS_BOUNDS_MAX_ONLY" or "OBS_BOUNDS_NONE".
            bounds.x (int) optional: The new width of the bounding box.
            bounds.y (int) optional: The new height of the bounding box.
            crop.bottom (int) optional: The new amount of pixels cropped off the bottom of the source before scaling.
            crop.left (int) optional: The new amount of pixels cropped off the left of the source before scaling.
            crop.right (int) optional: The new amount of pixels cropped off the right of the source before scaling.
            crop.top (int) optional: The new amount of pixels cropped off the top of the source before scaling.
            item.id (int) optional: Scene Item ID (if the `item` field is an object)
            item.name (str) optional: Scene Item name (if the `item` field is an object)
            locked (bool) optional: The new locked status of the source. 'true' keeps it in its current position, 'false' allows movement.
            position.alignment (int) optional: The new alignment of the source.
            position.x (int) optional: The new x position of the source.
            position.y (int) optional: The new y position of the source.
            rotation (int) optional: The new clockwise rotation of the item in degrees.
            scale.filter (str) optional: The new scale filter of the source. Can be "OBS_SCALE_DISABLE", "OBS_SCALE_POINT", "OBS_SCALE_BICUBIC", "OBS_SCALE_BILINEAR", "OBS_SCALE_LANCZOS" or "OBS_SCALE_AREA".
            scale.x (int) optional: The new x scale of the item.
            scale.y (int) optional: The new y scale of the item.
            scene-name (str) optional: Name of the scene the source item belongs to. Defaults to the current scene.
            visible (bool) optional: The new visibility of the source. 'true' shows source, 'false' hides source.
    """

    def __init__(self):
        """Init."""

        super(SetSceneItemProperties, self).__init__()

    async def init(
        self,
        item: str,
        bounds_alignment: Optional[int] = None,
        bounds_type: Optional[str] = None,
        bounds_x: Optional[int] = None,
        bounds_y: Optional[int] = None,
        crop_bottom: Optional[int] = None,
        crop_left: Optional[int] = None,
        crop_right: Optional[int] = None,
        crop_top: Optional[int] = None,
        item_id: Optional[int] = None,
        item_name: Optional[str] = None,
        locked: Optional[bool] = None,
        position_alignment: Optional[int] = None,
        position_x: Optional[int] = None,
        position_y: Optional[int] = None,
        rotation: Optional[int] = None,
        scale_filter: Optional[str] = None,
        scale_x: Optional[int] = None,
        scale_y: Optional[int] = None,
        scene_name: Optional[str] = None,
        visible: Optional[bool] = None,
    ):
        """Async init."""

        self.name = 'SetSceneItemProperties'
        self.data_out['item'] = item
        self.data_out['bounds.alignment'] = bounds_alignment
        self.data_out['bounds.type'] = bounds_type
        self.data_out['bounds.x'] = bounds_x
        self.data_out['bounds.y'] = bounds_y
        self.data_out['crop.bottom'] = crop_bottom
        self.data_out['crop.left'] = crop_left
        self.data_out['crop.right'] = crop_right
        self.data_out['crop.top'] = crop_top
        self.data_out['item.id'] = item_id
        self.data_out['item.name'] = item_name
        self.data_out['locked'] = locked
        self.data_out['position.alignment'] = position_alignment
        self.data_out['position.x'] = position_x
        self.data_out['position.y'] = position_y
        self.data_out['rotation'] = rotation
        self.data_out['scale.filter'] = scale_filter
        self.data_out['scale.x'] = scale_x
        self.data_out['scale.y'] = scale_y
        self.data_out['scene-name'] = scene_name
        self.data_out['visible'] = visible
        return self


class SetSceneItemRender(BaseRequests):
    """Show or hide a specified source item in a specified scene.

    Args:
        render (bool): true = shown ; false = hidden
        item (int) optional: Scene Item id
        scene-name (str) optional: Name of the scene the scene item belongs to. Defaults to the currently active scene.
        source (str) optional: Scene Item name.
    """

    def __init__(self):
        """Init."""

        super(SetSceneItemRender, self).__init__()

    async def init(
        self,
        render: bool,
        item: Optional[int] = None,
        scene_name: Optional[str] = None,
        source: Optional[str] = None,
    ):
        """Async init."""

        self.name = 'SetSceneItemRender'
        self.data_out['render'] = render
        self.data_out['item'] = item
        self.data_out['scene-name'] = scene_name
        self.data_out['source'] = source
        return self


class SetSceneItemTransform(BaseRequests):
    """Set the transform of the specified source item.

    Args:
        item (str): Scene Item name.
        rotation (int): Source item rotation (in degrees).
        x-scale (int): Width scale factor.
        y-scale (int): Height scale factor.
        scene-name (str) optional: Name of the scene the scene item belongs to. Defaults to the current scene.
    """

    def __init__(self):
        """Init."""

        super(SetSceneItemTransform, self).__init__()

    async def init(
        self,
        item: str,
        rotation: int,
        x_scale: int,
        y_scale: int,
        scene_name: Optional[str] = None,
    ):
        """Async init."""

        self.name = 'SetSceneItemTransform'
        self.data_out['item'] = item
        self.data_out['rotation'] = rotation
        self.data_out['x-scale'] = x_scale
        self.data_out['y-scale'] = y_scale
        self.data_out['scene-name'] = scene_name
        return self


class SetSceneTransitionOverride(BaseRequests):
    """Set a scene to use a specific transition override.

    Args:
        sceneName (str): Name of the scene to switch to.
        transitionDuration (int): Duration in milliseconds of the transition if transition is not fixed. Defaults to the current duration specified in the UI if there is no current override and this value is not given.
        transitionName (str): Name of the transition to use.
    """

    def __init__(self):
        """Init."""

        super(SetSceneTransitionOverride, self).__init__()

    async def init(
        self, sceneName: str, transitionDuration: int, transitionName: str
    ):
        """Async init."""

        self.name = 'SetSceneTransitionOverride'
        self.data_out['sceneName'] = sceneName
        self.data_out['transitionDuration'] = transitionDuration
        self.data_out['transitionName'] = transitionName
        return self


class SetSourceFilterSettings(BaseRequests):
    """Update settings of a filter

    Args:
        filterName (str): Name of the filter to reconfigure
        filterSettings (object): New settings. These will be merged to the current filter settings.
        sourceName (str): Name of the source to which the filter belongs
    """

    def __init__(self):
        """Init."""

        super(SetSourceFilterSettings, self).__init__()

    async def init(
        self, filterName: str, filterSettings: object, sourceName: str
    ):
        """Async init."""

        self.name = 'SetSourceFilterSettings'
        self.data_out['filterName'] = filterName
        self.data_out['filterSettings'] = filterSettings
        self.data_out['sourceName'] = sourceName
        return self


class SetSourceFilterVisibility(BaseRequests):
    """Change the visibility/enabled state of a filter

    Args:
        filterEnabled (bool): New filter state
        filterName (str): Source filter name
        sourceName (str): Source name
    """

    def __init__(self):
        """Init."""

        super(SetSourceFilterVisibility, self).__init__()

    async def init(
        self, filterEnabled: bool, filterName: str, sourceName: str
    ):
        """Async init."""

        self.name = 'SetSourceFilterVisibility'
        self.data_out['filterEnabled'] = filterEnabled
        self.data_out['filterName'] = filterName
        self.data_out['sourceName'] = sourceName
        return self


class SetSourceName(BaseRequests):
    """Note: If the new name already exists as a source, obs-websocket will return an error.

    Args:
        newName (str): New source name.
        sourceName (str): Source name.
    """

    def __init__(self):
        """Init."""

        super(SetSourceName, self).__init__()

    async def init(self, newName: str, sourceName: str):
        """Async init."""

        self.name = 'SetSourceName'
        self.data_out['newName'] = newName
        self.data_out['sourceName'] = sourceName
        return self


class SetSourceSettings(BaseRequests):
    """Set settings of the specified source.

    Args:
        sourceName (str): Source name.
        sourceSettings (object): Source settings (varies between source types, may require some probing around).
        sourceType (str) optional: Type of the specified source. Useful for type-checking to avoid settings a set of settings incompatible with the actual source's type.

    Returns:
        sourceName (str): Source name
        sourceSettings (object): Updated source settings
        sourceType (str): Type of the specified source
    """

    def __init__(self):
        """Init."""

        super(SetSourceSettings, self).__init__()

    async def init(
        self,
        sourceName: str,
        sourceSettings: object,
        sourceType: Optional[str] = None,
    ):
        """Async init."""

        self.name = 'SetSourceSettings'
        self.data_in['sourceName'] = None
        self.data_in['sourceSettings'] = None
        self.data_in['sourceType'] = None
        self.data_out['sourceName'] = sourceName
        self.data_out['sourceSettings'] = sourceSettings
        self.data_out['sourceType'] = sourceType
        return self

    async def get_sourceName(self):
        return self.data_in['sourceName']

    async def get_sourceSettings(self):
        return self.data_in['sourceSettings']

    async def get_sourceType(self):
        return self.data_in['sourceType']


class SetStreamSettings(BaseRequests):
    """Sets one or more attributes of the current streaming server settings. Any options not passed will remain unchanged. Returns the updated settings in response. If 'type' is different than the current streaming service type, all settings are required. Returns the full settings of the stream (the same as GetStreamSettings).

    Args:
        save (bool): Persist the settings to disk.
        settings (object): The actual settings of the stream.
        type (str): The type of streaming service configuration, usually `rtmp_custom` or `rtmp_common`.
        settings.key (str) optional: The publish key.
        settings.password (str) optional: The password for the streaming service.
        settings.server (str) optional: The publish URL.
        settings.use_auth (bool) optional: Indicates whether authentication should be used when connecting to the streaming server.
        settings.username (str) optional: The username for the streaming service.
    """

    def __init__(self):
        """Init."""

        super(SetStreamSettings, self).__init__()

    async def init(
        self,
        save: bool,
        settings: object,
        type: str,
        settings_key: Optional[str] = None,
        settings_password: Optional[str] = None,
        settings_server: Optional[str] = None,
        settings_use_auth: Optional[bool] = None,
        settings_username: Optional[str] = None,
    ):
        """Async init."""

        self.name = 'SetStreamSettings'
        self.data_out['save'] = save
        self.data_out['settings'] = settings
        self.data_out['type'] = type
        self.data_out['settings.key'] = settings_key
        self.data_out['settings.password'] = settings_password
        self.data_out['settings.server'] = settings_server
        self.data_out['settings.use_auth'] = settings_use_auth
        self.data_out['settings.username'] = settings_username
        return self


class SetSyncOffset(BaseRequests):
    """Set the audio sync offset of a specified source.

    Args:
        offset (int): The desired audio sync offset (in nanoseconds).
        source (str): Source name.
    """

    def __init__(self):
        """Init."""

        super(SetSyncOffset, self).__init__()

    async def init(self, offset: int, source: str):
        """Async init."""

        self.name = 'SetSyncOffset'
        self.data_out['offset'] = offset
        self.data_out['source'] = source
        return self


class SetTBarPosition(BaseRequests):
    """If your code needs to perform multiple successive T-Bar moves (e.g. : in an animation, or in response to a user moving a T-Bar control in your User Interface), set `release` to false and call `ReleaseTBar` later once the animation/interaction is over.

    Args:
        position (int): T-Bar position. This value must be between 0.0 and 1.0.
        release (bool) optional: Whether or not the T-Bar gets released automatically after setting its new position (like a user releasing their mouse button after moving the T-Bar). Call `ReleaseTBar` manually if you set `release` to false. Defaults to true.
    """

    def __init__(self):
        """Init."""

        super(SetTBarPosition, self).__init__()

    async def init(self, position: int, release: Optional[bool] = None):
        """Async init."""

        self.name = 'SetTBarPosition'
        self.data_out['position'] = position
        self.data_out['release'] = release
        return self


class SetTextFreetype2Properties(BaseRequests):
    """Set the current properties of a Text Freetype 2 source.

    Args:
        source (str): Source name.
        color1 (int) optional: Gradient top color.
        color2 (int) optional: Gradient bottom color.
        custom_width (int) optional: Custom width (0 to disable).
        drop_shadow (bool) optional: Drop shadow.
        font (object) optional: Holds data for the font. Ex: `"font": { "face": "Arial", "flags": 0, "size": 150, "style": "" }`
        font.face (str) optional: Font face.
        font.flags (int) optional: Font text styling flag. `Bold=1, Italic=2, Bold Italic=3, Underline=5, Strikeout=8`
        font.size (int) optional: Font text size.
        font.style (str) optional: Font Style (unknown function).
        from_file (bool) optional: Read text from the specified file.
        log_mode (bool) optional: Chat log.
        outline (bool) optional: Outline.
        text (str) optional: Text content to be displayed.
        text_file (str) optional: File path.
        word_wrap (bool) optional: Word wrap.
    """

    def __init__(self):
        """Init."""

        super(SetTextFreetype2Properties, self).__init__()

    async def init(
        self,
        source: str,
        color1: Optional[int] = None,
        color2: Optional[int] = None,
        custom_width: Optional[int] = None,
        drop_shadow: Optional[bool] = None,
        font: Optional[object] = None,
        font_face: Optional[str] = None,
        font_flags: Optional[int] = None,
        font_size: Optional[int] = None,
        font_style: Optional[str] = None,
        from_file: Optional[bool] = None,
        log_mode: Optional[bool] = None,
        outline: Optional[bool] = None,
        text: Optional[str] = None,
        text_file: Optional[str] = None,
        word_wrap: Optional[bool] = None,
    ):
        """Async init."""

        self.name = 'SetTextFreetype2Properties'
        self.data_out['source'] = source
        self.data_out['color1'] = color1
        self.data_out['color2'] = color2
        self.data_out['custom_width'] = custom_width
        self.data_out['drop_shadow'] = drop_shadow
        self.data_out['font'] = font
        self.data_out['font.face'] = font_face
        self.data_out['font.flags'] = font_flags
        self.data_out['font.size'] = font_size
        self.data_out['font.style'] = font_style
        self.data_out['from_file'] = from_file
        self.data_out['log_mode'] = log_mode
        self.data_out['outline'] = outline
        self.data_out['text'] = text
        self.data_out['text_file'] = text_file
        self.data_out['word_wrap'] = word_wrap
        return self


class SetTextGDIPlusProperties(BaseRequests):
    """Set the current properties of a Text GDI Plus source.

    Args:
        source (str): Name of the source.
        align (str) optional: Text Alignment ("left", "center", "right").
        bk_color (int) optional: Background color.
        bk_opacity (int) optional: Background opacity (0-100).
        chatlog (bool) optional: Chat log.
        chatlog_lines (int) optional: Chat log lines.
        color (int) optional: Text color.
        extents (bool) optional: Extents wrap.
        extents_cx (int) optional: Extents cx.
        extents_cy (int) optional: Extents cy.
        file (str) optional: File path name.
        font (object) optional: Holds data for the font. Ex: `"font": { "face": "Arial", "flags": 0, "size": 150, "style": "" }`
        font.face (str) optional: Font face.
        font.flags (int) optional: Font text styling flag. `Bold=1, Italic=2, Bold Italic=3, Underline=5, Strikeout=8`
        font.size (int) optional: Font text size.
        font.style (str) optional: Font Style (unknown function).
        gradient (bool) optional: Gradient enabled.
        gradient_color (int) optional: Gradient color.
        gradient_dir (float) optional: Gradient direction.
        gradient_opacity (int) optional: Gradient opacity (0-100).
        outline (bool) optional: Outline.
        outline_color (int) optional: Outline color.
        outline_opacity (int) optional: Outline opacity (0-100).
        outline_size (int) optional: Outline size.
        read_from_file (bool) optional: Read text from the specified file.
        render (bool) optional: Visibility of the scene item.
        text (str) optional: Text content to be displayed.
        valign (str) optional: Text vertical alignment ("top", "center", "bottom").
        vertical (bool) optional: Vertical text enabled.
    """

    def __init__(self):
        """Init."""

        super(SetTextGDIPlusProperties, self).__init__()

    async def init(
        self,
        source: str,
        align: Optional[str] = None,
        bk_color: Optional[int] = None,
        bk_opacity: Optional[int] = None,
        chatlog: Optional[bool] = None,
        chatlog_lines: Optional[int] = None,
        color: Optional[int] = None,
        extents: Optional[bool] = None,
        extents_cx: Optional[int] = None,
        extents_cy: Optional[int] = None,
        file: Optional[str] = None,
        font: Optional[object] = None,
        font_face: Optional[str] = None,
        font_flags: Optional[int] = None,
        font_size: Optional[int] = None,
        font_style: Optional[str] = None,
        gradient: Optional[bool] = None,
        gradient_color: Optional[int] = None,
        gradient_dir: Optional[float] = None,
        gradient_opacity: Optional[int] = None,
        outline: Optional[bool] = None,
        outline_color: Optional[int] = None,
        outline_opacity: Optional[int] = None,
        outline_size: Optional[int] = None,
        read_from_file: Optional[bool] = None,
        render: Optional[bool] = None,
        text: Optional[str] = None,
        valign: Optional[str] = None,
        vertical: Optional[bool] = None,
    ):
        """Async init."""

        self.name = 'SetTextGDIPlusProperties'
        self.data_out['source'] = source
        self.data_out['align'] = align
        self.data_out['bk_color'] = bk_color
        self.data_out['bk_opacity'] = bk_opacity
        self.data_out['chatlog'] = chatlog
        self.data_out['chatlog_lines'] = chatlog_lines
        self.data_out['color'] = color
        self.data_out['extents'] = extents
        self.data_out['extents_cx'] = extents_cx
        self.data_out['extents_cy'] = extents_cy
        self.data_out['file'] = file
        self.data_out['font'] = font
        self.data_out['font.face'] = font_face
        self.data_out['font.flags'] = font_flags
        self.data_out['font.size'] = font_size
        self.data_out['font.style'] = font_style
        self.data_out['gradient'] = gradient
        self.data_out['gradient_color'] = gradient_color
        self.data_out['gradient_dir'] = gradient_dir
        self.data_out['gradient_opacity'] = gradient_opacity
        self.data_out['outline'] = outline
        self.data_out['outline_color'] = outline_color
        self.data_out['outline_opacity'] = outline_opacity
        self.data_out['outline_size'] = outline_size
        self.data_out['read_from_file'] = read_from_file
        self.data_out['render'] = render
        self.data_out['text'] = text
        self.data_out['valign'] = valign
        self.data_out['vertical'] = vertical
        return self


class SetTransitionDuration(BaseRequests):
    """Set the duration of the currently selected transition if supported.

    Args:
        duration (int): Desired duration of the transition (in milliseconds).
    """

    def __init__(self):
        """Init."""

        super(SetTransitionDuration, self).__init__()

    async def init(self, duration: int):
        """Async init."""

        self.name = 'SetTransitionDuration'
        self.data_out['duration'] = duration
        return self


class SetTransitionSettings(BaseRequests):
    """Change the current settings of a transition

    Args:
        transitionName (str): Transition name
        transitionSettings (object): Transition settings (they can be partial)

    Returns:
        transitionSettings (object): Updated transition settings
    """

    def __init__(self):
        """Init."""

        super(SetTransitionSettings, self).__init__()

    async def init(self, transitionName: str, transitionSettings: object):
        """Async init."""

        self.name = 'SetTransitionSettings'
        self.data_in['transitionSettings'] = None
        self.data_out['transitionName'] = transitionName
        self.data_out['transitionSettings'] = transitionSettings
        return self

    async def get_transitionSettings(self):
        return self.data_in['transitionSettings']


class SetVolume(BaseRequests):
    """Set the volume of the specified source. Default request format uses mul, NOT SLIDER PERCENTAGE.

    Args:
        source (str): Source name.
        volume (int): Desired volume. Must be between `0.0` and `20.0` for mul, and under 26.0 for dB. OBS will interpret dB values under -100.0 as Inf. Note: The OBS volume sliders only reach a maximum of 1.0mul/0.0dB, however OBS actually supports larger values.
        useDecibel (bool) optional: Interperet `volume` data as decibels instead of amplitude/mul.
    """

    def __init__(self):
        """Init."""

        super(SetVolume, self).__init__()

    async def init(
        self, source: str, volume: int, useDecibel: Optional[bool] = None
    ):
        """Async init."""

        self.name = 'SetVolume'
        self.data_out['source'] = source
        self.data_out['volume'] = volume
        self.data_out['useDecibel'] = useDecibel
        return self


class Sleep(BaseRequests):
    """Waits for the specified duration. Designed to be used in `ExecuteBatch` operations.

    Args:
        sleepMillis (int): Delay in milliseconds to wait before continuing.
    """

    def __init__(self):
        """Init."""

        super(Sleep, self).__init__()

    async def init(self, sleepMillis: int):
        """Async init."""

        self.name = 'Sleep'
        self.data_out['sleepMillis'] = sleepMillis
        return self


class StartOutput(BaseRequests):
    """Note: Controlling outputs is an experimental feature of obs-websocket. Some plugins which add outputs to OBS may not function properly when they are controlled in this way.

    Args:
        outputName (str): Output name
    """

    def __init__(self):
        """Init."""

        super(StartOutput, self).__init__()

    async def init(self, outputName: str):
        """Async init."""

        self.name = 'StartOutput'
        self.data_out['outputName'] = outputName
        return self


class StartRecording(BaseRequests):
    """Start recording.
    Will return an `error` if recording is already active.
    """

    def __init__(self):
        """Init."""

        super(StartRecording, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'StartRecording'
        return self


class StartReplayBuffer(BaseRequests):
    """Start recording into the Replay Buffer.
    Will return an `error` if the Replay Buffer is already active or if the
    "Save Replay Buffer" hotkey is not set in OBS' settings.
    Setting this hotkey is mandatory, even when triggering saves only
    through obs-websocket.
    """

    def __init__(self):
        """Init."""

        super(StartReplayBuffer, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'StartReplayBuffer'
        return self


class StartStopRecording(BaseRequests):
    """Toggle recording on or off (depending on the current recording state)."""

    def __init__(self):
        """Init."""

        super(StartStopRecording, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'StartStopRecording'
        return self


class StartStopReplayBuffer(BaseRequests):
    """Toggle the Replay Buffer on/off (depending on the current state of the replay buffer)."""

    def __init__(self):
        """Init."""

        super(StartStopReplayBuffer, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'StartStopReplayBuffer'
        return self


class StartStopStreaming(BaseRequests):
    """Toggle streaming on or off (depending on the current stream state)."""

    def __init__(self):
        """Init."""

        super(StartStopStreaming, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'StartStopStreaming'
        return self


class StartStopVirtualCam(BaseRequests):
    """Toggle virtual cam on or off (depending on the current virtual cam state)."""

    def __init__(self):
        """Init."""

        super(StartStopVirtualCam, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'StartStopVirtualCam'
        return self


class StartStreaming(BaseRequests):
    """Start streaming.
    Will return an `error` if streaming is already active.

        Args:
            stream (object) optional: Special stream configuration. Note: these won't be saved to OBS' configuration.
            stream.metadata (object) optional: Adds the given object parameters as encoded query string parameters to the 'key' of the RTMP stream. Used to pass data to the RTMP service about the streaming. May be any String, Numeric, or Boolean field.
            stream.settings (object) optional: Settings for the stream.
            stream.settings.key (str) optional: The publish key of the stream.
            stream.settings.password (str) optional: If authentication is enabled, the password for the streaming server. Ignored if `use_auth` is not set to `true`.
            stream.settings.server (str) optional: The publish URL.
            stream.settings.use_auth (bool) optional: Indicates whether authentication should be used when connecting to the streaming server.
            stream.settings.username (str) optional: If authentication is enabled, the username for the streaming server. Ignored if `use_auth` is not set to `true`.
            stream.type (str) optional: If specified ensures the type of stream matches the given type (usually 'rtmp_custom' or 'rtmp_common'). If the currently configured stream type does not match the given stream type, all settings must be specified in the `settings` object or an error will occur when starting the stream.
    """

    def __init__(self):
        """Init."""

        super(StartStreaming, self).__init__()

    async def init(
        self,
        stream: Optional[object] = None,
        stream_metadata: Optional[object] = None,
        stream_settings: Optional[object] = None,
        stream_settings_key: Optional[str] = None,
        stream_settings_password: Optional[str] = None,
        stream_settings_server: Optional[str] = None,
        stream_settings_use_auth: Optional[bool] = None,
        stream_settings_username: Optional[str] = None,
        stream_type: Optional[str] = None,
    ):
        """Async init."""

        self.name = 'StartStreaming'
        self.data_out['stream'] = stream
        self.data_out['stream.metadata'] = stream_metadata
        self.data_out['stream.settings'] = stream_settings
        self.data_out['stream.settings.key'] = stream_settings_key
        self.data_out['stream.settings.password'] = stream_settings_password
        self.data_out['stream.settings.server'] = stream_settings_server
        self.data_out['stream.settings.use_auth'] = stream_settings_use_auth
        self.data_out['stream.settings.username'] = stream_settings_username
        self.data_out['stream.type'] = stream_type
        return self


class StartVirtualCam(BaseRequests):
    """Start virtual cam.
    Will return an `error` if virtual cam is already active.
    """

    def __init__(self):
        """Init."""

        super(StartVirtualCam, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'StartVirtualCam'
        return self


class StopMedia(BaseRequests):
    """Stop a media source. Supports ffmpeg and vlc media sources (as of OBS v25.0.8)

    Args:
        sourceName (str): Source name.
    """

    def __init__(self):
        """Init."""

        super(StopMedia, self).__init__()

    async def init(self, sourceName: str):
        """Async init."""

        self.name = 'StopMedia'
        self.data_out['sourceName'] = sourceName
        return self


class StopOutput(BaseRequests):
    """Note: Controlling outputs is an experimental feature of obs-websocket. Some plugins which add outputs to OBS may not function properly when they are controlled in this way.

    Args:
        outputName (str): Output name
        force (bool) optional: Force stop (default: false)
    """

    def __init__(self):
        """Init."""

        super(StopOutput, self).__init__()

    async def init(self, outputName: str, force: Optional[bool] = None):
        """Async init."""

        self.name = 'StopOutput'
        self.data_out['outputName'] = outputName
        self.data_out['force'] = force
        return self


class StopRecording(BaseRequests):
    """Stop recording.
    Will return an `error` if recording is not active.
    """

    def __init__(self):
        """Init."""

        super(StopRecording, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'StopRecording'
        return self


class StopReplayBuffer(BaseRequests):
    """Stop recording into the Replay Buffer.
    Will return an `error` if the Replay Buffer is not active.
    """

    def __init__(self):
        """Init."""

        super(StopReplayBuffer, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'StopReplayBuffer'
        return self


class StopStreaming(BaseRequests):
    """Stop streaming.
    Will return an `error` if streaming is not active.
    """

    def __init__(self):
        """Init."""

        super(StopStreaming, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'StopStreaming'
        return self


class StopVirtualCam(BaseRequests):
    """Stop virtual cam.
    Will return an `error` if virtual cam is not active.
    """

    def __init__(self):
        """Init."""

        super(StopVirtualCam, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'StopVirtualCam'
        return self


class TakeSourceScreenshot(BaseRequests):
    """At least `embedPictureFormat` or `saveToFilePath` must be specified.

    Clients can specify `width` and `height` parameters to receive scaled pictures. Aspect ratio is
    preserved if only one of these two parameters is specified.

        Args:
            compressionQuality (int) optional: Compression ratio between -1 and 100 to write the image with. -1 is automatic, 1 is smallest file/most compression, 100 is largest file/least compression. Varies with image type.
            embedPictureFormat (str) optional: Format of the Data URI encoded picture. Can be "png", "jpg", "jpeg" or "bmp" (or any other value supported by Qt's Image module)
            fileFormat (str) optional: Format to save the image file as (one of the values provided in the `supported-image-export-formats` response field of `GetVersion`). If not specified, tries to guess based on file extension.
            height (int) optional: Screenshot height. Defaults to the source's base height.
            saveToFilePath (str) optional: Full file path (file extension included) where the captured image is to be saved. Can be in a format different from `pictureFormat`. Can be a relative path.
            sourceName (str) optional: Source name. Note: Since scenes are also sources, you can also provide a scene name. If not provided, the currently active scene is used.
            width (int) optional: Screenshot width. Defaults to the source's base width.

        Returns:
            imageFile (str): Absolute path to the saved image file (if `saveToFilePath` was specified in the request)
            img (str): Image Data URI (if `embedPictureFormat` was specified in the request)
            sourceName (str): Source name
    """

    def __init__(self):
        """Init."""

        super(TakeSourceScreenshot, self).__init__()

    async def init(
        self,
        compressionQuality: Optional[int] = None,
        embedPictureFormat: Optional[str] = None,
        fileFormat: Optional[str] = None,
        height: Optional[int] = None,
        saveToFilePath: Optional[str] = None,
        sourceName: Optional[str] = None,
        width: Optional[int] = None,
    ):
        """Async init."""

        self.name = 'TakeSourceScreenshot'
        self.data_in['imageFile'] = None
        self.data_in['img'] = None
        self.data_in['sourceName'] = None
        self.data_out['compressionQuality'] = compressionQuality
        self.data_out['embedPictureFormat'] = embedPictureFormat
        self.data_out['fileFormat'] = fileFormat
        self.data_out['height'] = height
        self.data_out['saveToFilePath'] = saveToFilePath
        self.data_out['sourceName'] = sourceName
        self.data_out['width'] = width
        return self

    async def get_imageFile(self):
        return self.data_in['imageFile']

    async def get_img(self):
        return self.data_in['img']

    async def get_sourceName(self):
        return self.data_in['sourceName']


class ToggleMute(BaseRequests):
    """Inverts the mute status of a specified source.

    Args:
        source (str): Source name.
    """

    def __init__(self):
        """Init."""

        super(ToggleMute, self).__init__()

    async def init(self, source: str):
        """Async init."""

        self.name = 'ToggleMute'
        self.data_out['source'] = source
        return self


class ToggleStudioMode(BaseRequests):
    """Toggles Studio Mode (depending on the current state of studio mode)."""

    def __init__(self):
        """Init."""

        super(ToggleStudioMode, self).__init__()

    async def init(self):
        """Async init."""

        self.name = 'ToggleStudioMode'
        return self


class TransitionToProgram(BaseRequests):
    """Transitions the currently previewed scene to the main output.
    Will return an `error` if Studio Mode is not enabled.

        Args:
            with-transition.name (str): Name of the transition.
            with-transition (object) optional: Change the active transition before switching scenes. Defaults to the active transition.
            with-transition.duration (int) optional: Transition duration (in milliseconds).
    """

    def __init__(self):
        """Init."""

        super(TransitionToProgram, self).__init__()

    async def init(
        self,
        with_transition_name: str,
        with_transition: Optional[object] = None,
        with_transition_duration: Optional[int] = None,
    ):
        """Async init."""

        self.name = 'TransitionToProgram'
        self.data_out['with-transition.name'] = with_transition_name
        self.data_out['with-transition'] = with_transition
        self.data_out['with-transition.duration'] = with_transition_duration
        return self


class TriggerHotkeyByName(BaseRequests):
    """Executes hotkey routine, identified by hotkey unique name

    Args:
        hotkeyName (str): Unique name of the hotkey, as defined when registering the hotkey (e.g. "ReplayBuffer.Save")
    """

    def __init__(self):
        """Init."""

        super(TriggerHotkeyByName, self).__init__()

    async def init(self, hotkeyName: str):
        """Async init."""

        self.name = 'TriggerHotkeyByName'
        self.data_out['hotkeyName'] = hotkeyName
        return self


class TriggerHotkeyBySequence(BaseRequests):
    """Executes hotkey routine, identified by bound combination of keys. A single key combination might trigger multiple hotkey routines depending on user settings

    Args:
        keyId (str): Main key identifier (e.g. `OBS_KEY_A` for key "A"). Available identifiers [here](https://github.com/obsproject/obs-studio/blob/master/libobs/obs-hotkeys.h)
        keyModifiers (object): Optional key modifiers object. False entries can be ommitted
        keyModifiers.alt (bool): Trigger Alt Key
        keyModifiers.command (bool): Trigger Command Key (Mac)
        keyModifiers.control (bool): Trigger Control (Ctrl) Key
        keyModifiers.shift (bool): Trigger Shift Key
    """

    def __init__(self):
        """Init."""

        super(TriggerHotkeyBySequence, self).__init__()

    async def init(
        self,
        keyId: str,
        keyModifiers: object,
        keyModifiers_alt: bool,
        keyModifiers_command: bool,
        keyModifiers_control: bool,
        keyModifiers_shift: bool,
    ):
        """Async init."""

        self.name = 'TriggerHotkeyBySequence'
        self.data_out['keyId'] = keyId
        self.data_out['keyModifiers'] = keyModifiers
        self.data_out['keyModifiers.alt'] = keyModifiers_alt
        self.data_out['keyModifiers.command'] = keyModifiers_command
        self.data_out['keyModifiers.control'] = keyModifiers_control
        self.data_out['keyModifiers.shift'] = keyModifiers_shift
        return self
